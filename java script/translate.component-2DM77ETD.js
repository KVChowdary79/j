import {
    a as Pi,
    b as xt,
    c as kt
} from "./chunk-IYQ5WOL7.js";
import {
    a as hi
} from "./chunk-KZIF2JUR.js";
import {
    a as Ii,
    b as Li
} from "./chunk-L7GZPI7B.js";
import {
    a as yi,
    b as Ci,
    c as xi,
    d as $e,
    e as ki,
    f as Mi,
    g as jt,
    h as Ti,
    i as Ct,
    j as wi,
    k as Q,
    l as z
} from "./chunk-LF47DMI6.js";
import {
    a as Oi
} from "./chunk-KJV3VIQG.js";
import {
    d as Qe,
    e as Mt,
    f as Di
} from "./chunk-RJ3QQZ44.js";
import {
    C as Re,
    a as fi,
    b as _i,
    d as Ue,
    h as bt,
    i as vi,
    j as ht,
    k as Ut,
    m as _t,
    n as vt,
    o as yt,
    u as je
} from "./chunk-ZVDIJDKE.js";
import {
    a as $
} from "./chunk-G6X3EYPO.js";
import "./chunk-KSW6ZZ47.js";
import {
    a as Fn,
    b as An,
    c as mt,
    d as Vn,
    e as Ee,
    f as Nn,
    g as zn,
    h as Hn,
    i as Un,
    j as jn,
    k as $n,
    m as Qn,
    n as Wn,
    o as qn
} from "./chunk-C2KWHI4F.js";
import {
    b as Gn,
    i as Yn
} from "./chunk-DMMIEUFP.js";
import {
    a as Se
} from "./chunk-J7CTOMGD.js";
import "./chunk-PQFSWOT7.js";
import {
    a as ut
} from "./chunk-NA7WVPXZ.js";
import "./chunk-KEGCD5JT.js";
import {
    a as D,
    i as Si
} from "./chunk-U7BFU7SC.js";
import "./chunk-GLOBIKT5.js";
import {
    $ as dt,
    $a as gt,
    B,
    C as De,
    Ca as ei,
    Ea as ti,
    Ga as ni,
    I as ot,
    Ia as ii,
    J as Dn,
    Ja as ai,
    K as rt,
    L as En,
    M as Rn,
    Ma as oi,
    N as st,
    Oa as ri,
    Qa as si,
    Sa as ci,
    W as ct,
    X as lt,
    Ya as li,
    Za as di,
    _a as pi,
    aa as ke,
    ab as mi,
    c as wn,
    d as Sn,
    db as ui,
    e as Pn,
    fa as F,
    ga as Bn,
    ha as zt,
    hb as gi,
    ib as bi,
    ja as pt,
    jb as A,
    kb as Ht,
    la as K,
    m as In,
    ma as Z,
    mb as ft,
    o as Ln,
    oa as Kn,
    p as nt,
    pa as Zn,
    q as On,
    r as it,
    s as at,
    va as Xn,
    xa as Jn
} from "./chunk-GFV577OQ.js";
import {
    $ as T,
    $b as V,
    A as fe,
    Ba as W,
    C as ce,
    Ca as ye,
    Cb as hn,
    Db as k,
    Ea as Te,
    Eb as m,
    Fb as fn,
    Ga as le,
    Gb as E,
    H as Bt,
    Hb as Ce,
    I as cn,
    Ib as b,
    Ic as Nt,
    Ja as Ke,
    Jb as de,
    K as ln,
    Kb as ne,
    Lb as ie,
    M as Ft,
    Mb as l,
    Nb as p,
    Oa as Le,
    Ob as u,
    Oc as Mn,
    Pb as ae,
    Pc as Y,
    Qb as oe,
    Rb as At,
    Rc as Tn,
    Sb as w,
    Ta as Oe,
    Ub as v,
    V as dn,
    Vb as r,
    W as pn,
    Wb as ue,
    X as mn,
    Xb as pe,
    Y as _e,
    Z as Me,
    Zb as ge,
    _ as y,
    _b as G,
    a as re,
    ac as N,
    bc as Je,
    ca as un,
    cc as et,
    d as Ge,
    da as Ye,
    dc as me,
    eb as bn,
    ec as I,
    fa as se,
    fc as j,
    g as ee,
    gc as H,
    hb as c,
    hc as _n,
    ia as s,
    ic as vn,
    j as rn,
    jb as we,
    jc as yn,
    kc as Cn,
    lb as ze,
    lc as xe,
    m as Ve,
    mc as Vt,
    nb as He,
    nc as C,
    ob as Ze,
    oc as x,
    qa as ve,
    qc as xn,
    ra as f,
    sa as _,
    sb as h,
    ta as gn,
    tb as Xe,
    tc as be,
    ub as te,
    va as q,
    wb as P,
    x as R,
    xa as Ie,
    xb as g,
    y as sn,
    yc as U,
    z as Ne,
    zc as tt
} from "./chunk-DIJUAHOD.js";
import "./chunk-GN2XDD6F.js";
import {
    a as kn
} from "./chunk-5INLNTLQ.js";
import "./chunk-G53WN73B.js";
import "./chunk-7RKXYYCK.js";
import "./chunk-7JRWGPZB.js";
import "./chunk-TFYTOQTJ.js";
import "./chunk-LNXCJBU2.js";
import "./chunk-QYCU5LFW.js";
import "./chunk-ZGG45NVU.js";
import "./chunk-CBTCPHC5.js";
import "./chunk-5HUCFAOZ.js";
import "./chunk-DROM25MW.js";
import "./chunk-F4PI7WOR.js";
import "./chunk-ILNDS6YC.js";
import "./chunk-7T7YRGPO.js";
import {
    a as Rt,
    b as on,
    k as M
} from "./chunk-XDKSGOKZ.js";
var Ei = (() => {
    class n {
        constructor() {
            this.store = s(D), this.inputMode$ = this.store.select(e => e.translate.inputMode)
        }
        setInputMode() {
            this.store.dispatch(new An(this.mode))
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-translate-input-button"]
                ],
                inputs: {
                    mode: "mode",
                    icon: "icon"
                },
                decls: 5,
                vars: 8,
                consts: [
                    ["color", "primary", "fill", "outline", 3, "click"],
                    ["slot", "start", 3, "name"]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "ion-button", 0), C(1, "async"), v("click", function() {
                        return i.setInputMode()
                    }), u(2, "ion-icon", 1), I(3), C(4, "transloco"), p()), t & 2 && (E("selected", x(1, 4, i.inputMode$) === i.mode), c(2), m("name", i.icon), c(), H(" ", x(4, 6, "translate.input." + i.mode) || "\xA0", `
`))
                },
                dependencies: [B, F, Z, Y],
                styles: [`ion-button[_ngcontent-%COMP%]{--border-width: 1px;text-transform:none;--ion-color-base: var(--ion-color-primary-accessible-text) !important}ion-button.selected[_ngcontent-%COMP%]{border-radius:var(--border-radius);background-color:#a642f414}
/*# sourceMappingURL=button.component-QSXKN6PI.css.map */`]
            })
        }
    }
    return n
})();
var Ri = [{
    signed: "ads",
    spoken: "ak",
    country: "gh",
    abbreviation: ""
}, {
    signed: "sqk",
    spoken: "sq",
    country: "al",
    abbreviation: ""
}, {
    signed: "afg",
    spoken: "ps",
    country: "af",
    abbreviation: ""
}, {
    signed: "asp",
    spoken: "ar",
    country: "dz",
    abbreviation: ""
}, {
    signed: "syy",
    spoken: "ar",
    country: "ps",
    abbreviation: "ABSL"
}, {
    signed: "jks",
    spoken: "ja",
    country: "jp",
    abbreviation: ""
}, {
    signed: "ase",
    spoken: "en",
    country: "us",
    abbreviation: "ASL"
}, {
    signed: "aed",
    spoken: "es",
    country: "ar",
    abbreviation: ""
}, {
    signed: "aen",
    spoken: "hy",
    country: "am",
    abbreviation: ""
}, {
    signed: "asf",
    spoken: "en",
    country: "au",
    abbreviation: "Auslan"
}, {
    signed: "asw",
    spoken: "en",
    country: "au",
    abbreviation: ""
}, {
    signed: "asq",
    spoken: "de",
    country: "at",
    abbreviation: "\xD6GS"
}, {
    signed: "bog",
    spoken: "fr",
    country: "ml",
    abbreviation: ""
}, {
    signed: "bfk",
    spoken: "th",
    country: "th",
    abbreviation: ""
}, {
    signed: "bqy",
    spoken: "id",
    country: "id",
    abbreviation: ""
}, {
    signed: "bvl",
    spoken: "es",
    country: "bo",
    abbreviation: ""
}, {
    signed: "bzs",
    spoken: "pt",
    country: "br",
    abbreviation: ""
}, {
    signed: "bfi",
    spoken: "en",
    country: "gb",
    abbreviation: "BSL"
}, {
    signed: "bqn",
    spoken: "bg",
    country: "bg",
    abbreviation: ""
}, {
    signed: "lsb",
    spoken: "fr",
    country: "bi",
    abbreviation: ""
}, {
    signed: "csx",
    spoken: "km",
    country: "kh",
    abbreviation: ""
}, {
    signed: "csc",
    spoken: "ca",
    country: "es",
    abbreviation: ""
}, {
    signed: "cds",
    spoken: "fr",
    country: "td",
    abbreviation: ""
}, {
    signed: "csd",
    spoken: "th",
    country: "th",
    abbreviation: ""
}, {
    signed: "csg",
    spoken: "es",
    country: "cl",
    abbreviation: ""
}, {
    signed: "csl",
    spoken: "zh",
    country: "cn",
    abbreviation: ""
}, {
    signed: "csn",
    spoken: "es",
    country: "co",
    abbreviation: ""
}, {
    signed: "csr",
    spoken: "es",
    country: "cr",
    abbreviation: ""
}, {
    signed: "csq",
    spoken: "hr",
    country: "hr",
    abbreviation: ""
}, {
    signed: "csf",
    spoken: "es",
    country: "cu",
    abbreviation: ""
}, {
    signed: "cse",
    spoken: "cs",
    country: "cz",
    abbreviation: "CZJ"
}, {
    signed: "dsl",
    spoken: "da",
    country: "dk",
    abbreviation: ""
}, {
    signed: "doq",
    spoken: "es",
    country: "do",
    abbreviation: ""
}, {
    signed: "dse",
    spoken: "nl",
    country: "nl",
    abbreviation: "NGT"
}, {
    signed: "ecs",
    spoken: "es",
    country: "ec",
    abbreviation: ""
}, {
    signed: "esl",
    spoken: "ar",
    country: "eg",
    abbreviation: ""
}, {
    signed: "eso",
    spoken: "et",
    country: "ee",
    abbreviation: ""
}, {
    signed: "eth",
    spoken: "am",
    country: "et",
    abbreviation: ""
}, {
    signed: "fss",
    spoken: "fi",
    country: "fi",
    abbreviation: ""
}, {
    signed: "fse",
    spoken: "fi",
    country: "fi",
    abbreviation: ""
}, {
    signed: "fsl",
    spoken: "fr",
    country: "fr",
    abbreviation: "LSF"
}, {
    signed: "gsg",
    spoken: "de",
    country: "de",
    abbreviation: "DGS"
}, {
    signed: "gds",
    spoken: "ne",
    country: "np",
    abbreviation: ""
}, {
    signed: "gse",
    spoken: "ak",
    country: "gh",
    abbreviation: ""
}, {
    signed: "gss",
    spoken: "el",
    country: "gr",
    abbreviation: "GSL"
}, {
    signed: "gsm",
    spoken: "es",
    country: "gt",
    abbreviation: ""
}, {
    signed: "gus",
    spoken: "fr",
    country: "gn",
    abbreviation: ""
}, {
    signed: "haf",
    spoken: "vi",
    country: "vn",
    abbreviation: ""
}, {
    signed: "hab",
    spoken: "vi",
    country: "vn",
    abbreviation: ""
}, {
    signed: "hsl",
    spoken: "ha",
    country: "ng",
    abbreviation: ""
}, {
    signed: "hps",
    spoken: "en",
    country: "us",
    abbreviation: ""
}, {
    signed: "hos",
    spoken: "vi",
    country: "vn",
    abbreviation: ""
}, {
    signed: "hds",
    spoken: "es",
    country: "hn",
    abbreviation: ""
}, {
    signed: "hks",
    spoken: "zh",
    country: "hk",
    abbreviation: ""
}, {
    signed: "hsh",
    spoken: "hu",
    country: "hu",
    abbreviation: ""
}, {
    signed: "icl",
    spoken: "is",
    country: "is",
    abbreviation: ""
}, {
    signed: "ins",
    spoken: "hi",
    country: "in",
    abbreviation: "ISL"
}, {
    signed: "inl",
    spoken: "id",
    country: "id",
    abbreviation: ""
}, {
    signed: "iks",
    spoken: "iu",
    country: "ca",
    abbreviation: ""
}, {
    signed: "isg",
    spoken: "ga",
    country: "ie",
    abbreviation: "ISL"
}, {
    signed: "isr",
    spoken: "he",
    country: "il",
    abbreviation: "ISL"
}, {
    signed: "ise",
    spoken: "it",
    country: "it",
    abbreviation: "LIS"
}, {
    signed: "jcs",
    spoken: "en",
    country: "jm",
    abbreviation: ""
}, {
    signed: "jls",
    spoken: "en",
    country: "jm",
    abbreviation: ""
}, {
    signed: "jsl",
    spoken: "ja",
    country: "jp",
    abbreviation: "JSL"
}, {
    signed: "jhs",
    spoken: "ne",
    country: "np",
    abbreviation: ""
}, {
    signed: "jos",
    spoken: "ar",
    country: "jo",
    abbreviation: ""
}, {
    signed: "jos",
    spoken: "ar",
    country: "sy",
    abbreviation: ""
}, {
    signed: "jus",
    spoken: "ne",
    country: "np",
    abbreviation: ""
}, {
    signed: "xki",
    spoken: "en",
    country: "ke",
    abbreviation: ""
}, {
    signed: "kvk",
    spoken: "ko",
    country: "kr",
    abbreviation: ""
}, {
    signed: "sqx",
    spoken: "ar",
    country: "ps",
    abbreviation: ""
}, {
    signed: "lso",
    spoken: "lo",
    country: "la",
    abbreviation: ""
}, {
    signed: "lsl",
    spoken: "lv",
    country: "lv",
    abbreviation: ""
}, {
    signed: "lbs",
    spoken: "ar",
    country: "ly",
    abbreviation: ""
}, {
    signed: "lls",
    spoken: "lt",
    country: "lt",
    abbreviation: ""
}, {
    signed: "lsg",
    spoken: "fr",
    country: "fr",
    abbreviation: ""
}, {
    signed: "mzc",
    spoken: "fr",
    country: "mg",
    abbreviation: ""
}, {
    signed: "lws",
    spoken: "en",
    country: "mw",
    abbreviation: ""
}, {
    signed: "xml",
    spoken: "ms",
    country: "my",
    abbreviation: ""
}, {
    signed: "mdl",
    spoken: "mt",
    country: "mt",
    abbreviation: ""
}, {
    signed: "nsr",
    spoken: "en",
    country: "ca",
    abbreviation: ""
}, {
    signed: "lsy",
    spoken: "en",
    country: "mu",
    abbreviation: ""
}, {
    signed: "mre",
    spoken: "en",
    country: "us",
    abbreviation: "MVSL"
}, {
    signed: "mfs",
    spoken: "es",
    country: "mx",
    abbreviation: ""
}, {
    signed: "rsm",
    spoken: "en",
    country: "au",
    abbreviation: ""
}, {
    signed: "ehs",
    spoken: "ja",
    country: "jp",
    abbreviation: ""
}, {
    signed: "vsi",
    spoken: "ro",
    country: "md",
    abbreviation: ""
}, {
    signed: "mzg",
    spoken: "fr",
    country: "fr",
    abbreviation: ""
}, {
    signed: "msr",
    spoken: "mn",
    country: "mn",
    abbreviation: ""
}, {
    signed: "xms",
    spoken: "ar",
    country: "ma",
    abbreviation: ""
}, {
    signed: "mzy",
    spoken: "pt",
    country: "mz",
    abbreviation: ""
}, {
    signed: "ysm",
    spoken: "my",
    country: "mm",
    abbreviation: ""
}, {
    signed: "nbs",
    spoken: "en",
    country: "na",
    abbreviation: ""
}, {
    signed: "nsp",
    spoken: "ne",
    country: "np",
    abbreviation: ""
}, {
    signed: "nzs",
    spoken: "en",
    country: "nz",
    abbreviation: "NZSL"
}, {
    signed: "ncs",
    spoken: "es",
    country: "ni",
    abbreviation: ""
}, {
    signed: "nsi",
    spoken: "en",
    country: "ng",
    abbreviation: ""
}, {
    signed: "nsl",
    spoken: "no",
    country: "no",
    abbreviation: ""
}, {
    signed: "okl",
    spoken: "en",
    country: "gb",
    abbreviation: ""
}, {
    signed: "pks",
    spoken: "ur",
    country: "pk",
    abbreviation: ""
}, {
    signed: "lsp",
    spoken: "es",
    country: "pa",
    abbreviation: ""
}, {
    signed: "pgz",
    spoken: "en",
    country: "pg",
    abbreviation: ""
}, {
    signed: "pys",
    spoken: "es",
    country: "py",
    abbreviation: ""
}, {
    signed: "psg",
    spoken: "ms",
    country: "my",
    abbreviation: ""
}, {
    signed: "psc",
    spoken: "fa",
    country: "ir",
    abbreviation: ""
}, {
    signed: "prl",
    spoken: "es",
    country: "pe",
    abbreviation: ""
}, {
    signed: "psp",
    spoken: "en",
    country: "ph",
    abbreviation: ""
}, {
    signed: "psd",
    spoken: "en",
    country: "us",
    abbreviation: ""
}, {
    signed: "pso",
    spoken: "pl",
    country: "pl",
    abbreviation: "PJM"
}, {
    signed: "psr",
    spoken: "pt",
    country: "pt",
    abbreviation: ""
}, {
    signed: "prz",
    spoken: "es",
    country: "co",
    abbreviation: ""
}, {
    signed: "psl",
    spoken: "es",
    country: "pr",
    abbreviation: "PRSL"
}, {
    signed: "fcs",
    spoken: "fr",
    country: "ca",
    abbreviation: "LSQ"
}, {
    signed: "rsi",
    spoken: "en",
    country: "sb",
    abbreviation: ""
}, {
    signed: "rms",
    spoken: "ro",
    country: "ro",
    abbreviation: ""
}, {
    signed: "rsl",
    spoken: "ru",
    country: "ru",
    abbreviation: ""
}, {
    signed: "esn",
    spoken: "es",
    country: "sv",
    abbreviation: ""
}, {
    signed: "sdl",
    spoken: "ar",
    country: "sa",
    abbreviation: ""
}, {
    signed: "kgi",
    spoken: "ms",
    country: "my",
    abbreviation: ""
}, {
    signed: "sgx",
    spoken: "en",
    country: "sl",
    abbreviation: ""
}, {
    signed: "lsv",
    spoken: "en",
    country: "us",
    abbreviation: ""
}, {
    signed: "svk",
    spoken: "sk",
    country: "sk",
    abbreviation: "SPJ"
}, {
    signed: "sls",
    spoken: "en",
    country: "sg",
    abbreviation: ""
}, {
    signed: "szs",
    spoken: "en",
    country: "sb",
    abbreviation: ""
}, {
    signed: "sfb",
    spoken: "fr",
    country: "be",
    abbreviation: ""
}, {
    signed: "sfs",
    spoken: "af",
    country: "za",
    abbreviation: ""
}, {
    signed: "ssp",
    spoken: "es",
    country: "es",
    abbreviation: "LSE"
}, {
    signed: "sqs",
    spoken: "si",
    country: "lk",
    abbreviation: ""
}, {
    signed: "swl",
    spoken: "sv",
    country: "se",
    abbreviation: "STS"
}, {
    signed: "ssr",
    spoken: "fr",
    country: "ch",
    abbreviation: "LSF-CH"
}, {
    signed: "sgg",
    spoken: "de",
    country: "ch",
    abbreviation: "DSGS"
}, {
    signed: "slf",
    spoken: "it",
    country: "ch",
    abbreviation: "LIS-CH"
}, {
    signed: "tss",
    spoken: "zh",
    country: "tw",
    abbreviation: ""
}, {
    signed: "tza",
    spoken: "sw",
    country: "tz",
    abbreviation: ""
}, {
    signed: "tsy",
    spoken: "en",
    country: "ng",
    abbreviation: ""
}, {
    signed: "lsn",
    spoken: "bo",
    country: "cn",
    abbreviation: ""
}, {
    signed: "tsq",
    spoken: "th",
    country: "th",
    abbreviation: ""
}, {
    signed: "lst",
    spoken: "en",
    country: "tt",
    abbreviation: ""
}, {
    signed: "tse",
    spoken: "ar",
    country: "tn",
    abbreviation: ""
}, {
    signed: "tsm",
    spoken: "tr",
    country: "tr",
    abbreviation: ""
}, {
    signed: "ugn",
    spoken: "en",
    country: "ug",
    abbreviation: ""
}, {
    signed: "ukl",
    spoken: "uk",
    country: "ua",
    abbreviation: ""
}, {
    signed: "uks",
    spoken: "pt",
    country: "br",
    abbreviation: ""
}, {
    signed: "ugy",
    spoken: "es",
    country: "uy",
    abbreviation: ""
}, {
    signed: "vgt",
    spoken: "nl",
    country: "be",
    abbreviation: ""
}, {
    signed: "vsv",
    spoken: "ca",
    country: "es",
    abbreviation: ""
}, {
    signed: "vsl",
    spoken: "es",
    country: "ve",
    abbreviation: ""
}, {
    signed: "wbs",
    spoken: "bn",
    country: "in",
    abbreviation: ""
}, {
    signed: "yhs",
    spoken: "en",
    country: "au",
    abbreviation: ""
}, {
    signed: "yds",
    spoken: "yi",
    country: "us",
    abbreviation: ""
}, {
    signed: "ygs",
    spoken: "en",
    country: "au",
    abbreviation: ""
}, {
    signed: "msd",
    spoken: "es",
    country: "my",
    abbreviation: ""
}, {
    signed: "ysl",
    spoken: "sr",
    country: "yu",
    abbreviation: ""
}, {
    signed: "ysl",
    spoken: "sr",
    country: "rs",
    abbreviation: ""
}, {
    signed: "zsl",
    spoken: "en",
    country: "zm",
    abbreviation: ""
}, {
    signed: "zib",
    spoken: "en",
    country: "zw",
    abbreviation: ""
}, {
    signed: "ils",
    spoken: "",
    country: "",
    abbreviation: "IS"
}, {
    signed: "rsl-by",
    spoken: "be",
    country: "by",
    abbreviation: ""
}, {
    signed: "gss-cy",
    spoken: "el",
    country: "cy",
    abbreviation: ""
}];
var $t = class {
        _box;
        _destroyed = new ee;
        _resizeSubject = new ee;
        _resizeObserver;
        _elementObservables = new Map;
        constructor(o) {
            this._box = o, typeof ResizeObserver < "u" && (this._resizeObserver = new ResizeObserver(e => this._resizeSubject.next(e)))
        }
        observe(o) {
            return this._elementObservables.has(o) || this._elementObservables.set(o, new Ge(e => {
                let t = this._resizeSubject.subscribe(e);
                return this._resizeObserver ? .observe(o, {
                    box: this._box
                }), () => {
                    this._resizeObserver ? .unobserve(o), t.unsubscribe(), this._elementObservables.delete(o)
                }
            }).pipe(ce(e => e.some(t => t.target === o)), dn({
                bufferSize: 1,
                refCount: !0
            }), y(this._destroyed))), this._elementObservables.get(o)
        }
        destroy() {
            this._destroyed.next(), this._destroyed.complete(), this._resizeSubject.complete(), this._elementObservables.clear()
        }
    },
    Bi = (() => {
        class n {
            _cleanupErrorListener;
            _observers = new Map;
            _ngZone = s(ye);
            constructor() {
                typeof ResizeObserver < "u"
            }
            ngOnDestroy() {
                for (let [, e] of this._observers) e.destroy();
                this._observers.clear(), this._cleanupErrorListener ? .()
            }
            observe(e, t) {
                let i = t ? .box || "content-box";
                return this._observers.has(i) || this._observers.set(i, new $t(i)), this._observers.get(i).observe(e)
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275prov = un({
                token: n,
                factory: n.\u0275fac,
                providedIn: "root"
            })
        }
        return n
    })();
var Zt = ["*"];

function ba(n, o) {
    n & 1 && pe(0)
}
var ha = ["tabListContainer"],
    fa = ["tabList"],
    _a = ["tabListInner"],
    va = ["nextPaginator"],
    ya = ["previousPaginator"],
    Ca = ["content"];

function xa(n, o) {}
var ka = ["tabBodyWrapper"],
    Ma = ["tabHeader"];

function Ta(n, o) {}

function wa(n, o) {
    if (n & 1 && g(0, Ta, 0, 0, "ng-template", 12), n & 2) {
        let e = r().$implicit;
        m("cdkPortalOutlet", e.templateLabel)
    }
}

function Sa(n, o) {
    if (n & 1 && I(0), n & 2) {
        let e = r().$implicit;
        j(e.textLabel)
    }
}

function Pa(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "div", 7, 2), v("click", function() {
            let i = f(e),
                a = i.$implicit,
                d = i.$index,
                S = r(),
                L = me(1);
            return _(S._handleClick(a, L, d))
        })("cdkFocusChange", function(i) {
            let a = f(e).$index,
                d = r();
            return _(d._tabFocusChanged(i, a))
        }), u(2, "span", 8)(3, "div", 9), l(4, "span", 10)(5, "span", 11), g(6, wa, 1, 1, null, 12)(7, Sa, 1, 1), p()()()
    }
    if (n & 2) {
        let e = o.$implicit,
            t = o.$index,
            i = me(1),
            a = r();
        Ce(e.labelClass), E("mdc-tab--active", a.selectedIndex === t), m("id", a._getTabLabelId(t))("disabled", e.disabled)("fitInkBarToContent", a.fitInkBarToContent), k("tabIndex", a._getTabIndex(t))("aria-posinset", t + 1)("aria-setsize", a._tabs.length)("aria-controls", a._getTabContentId(t))("aria-selected", a.selectedIndex === t)("aria-label", e.ariaLabel || null)("aria-labelledby", !e.ariaLabel && e.ariaLabelledby ? e.ariaLabelledby : null), c(3), m("matRippleTrigger", i)("matRippleDisabled", e.disabled || a.disableRipple), c(3), b(e.templateLabel ? 6 : 7)
    }
}

function Ia(n, o) {
    n & 1 && pe(0)
}

function La(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "mat-tab-body", 13), v("_onCentered", function() {
            f(e);
            let i = r();
            return _(i._removeTabBodyWrapperHeight())
        })("_onCentering", function(i) {
            f(e);
            let a = r();
            return _(a._setTabBodyWrapperHeight(i))
        })("_beforeCentering", function(i) {
            f(e);
            let a = r();
            return _(a._bodyCentered(i))
        }), p()
    }
    if (n & 2) {
        let e = o.$implicit,
            t = o.$index,
            i = r();
        Ce(e.bodyClass), m("id", i._getTabContentId(t))("content", e.content)("position", e.position)("animationDuration", i.animationDuration)("preserveContent", i.preserveContent), k("tabindex", i.contentTabIndex != null && i.selectedIndex === t ? i.contentTabIndex : null)("aria-labelledby", i._getTabLabelId(t))("aria-hidden", i.selectedIndex !== t)
    }
}
var Oa = new se("MatTabContent"),
    Da = (() => {
        class n {
            template = s(we);
            constructor() {}
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275dir = te({
                type: n,
                selectors: [
                    ["", "matTabContent", ""]
                ],
                features: [xe([{
                    provide: Oa,
                    useExisting: n
                }])]
            })
        }
        return n
    })(),
    Ea = new se("MatTabLabel"),
    Ni = new se("MAT_TAB"),
    Xt = (() => {
        class n extends Mi {
            _closestTab = s(Ni, {
                optional: !0
            });
            static\ u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })();
            static\ u0275dir = te({
                type: n,
                selectors: [
                    ["", "mat-tab-label", ""],
                    ["", "matTabLabel", ""]
                ],
                features: [xe([{
                    provide: Ea,
                    useExisting: n
                }]), P]
            })
        }
        return n
    })(),
    zi = new se("MAT_TAB_GROUP"),
    Jt = (() => {
        class n {
            _viewContainerRef = s(He);
            _closestTabGroup = s(zi, {
                optional: !0
            });
            disabled = !1;
            get templateLabel() {
                return this._templateLabel
            }
            set templateLabel(e) {
                this._setTemplateLabelInput(e)
            }
            _templateLabel;
            _explicitContent = void 0;
            _implicitContent;
            textLabel = "";
            ariaLabel;
            ariaLabelledby;
            labelClass;
            bodyClass;
            _contentPortal = null;
            get content() {
                return this._contentPortal
            }
            _stateChanges = new ee;
            position = null;
            origin = null;
            isActive = !1;
            constructor() {
                s(ht).load(Mt)
            }
            ngOnChanges(e) {
                (e.hasOwnProperty("textLabel") || e.hasOwnProperty("disabled")) && this._stateChanges.next()
            }
            ngOnDestroy() {
                this._stateChanges.complete()
            }
            ngOnInit() {
                this._contentPortal = new $e(this._explicitContent || this._implicitContent, this._viewContainerRef)
            }
            _setTemplateLabelInput(e) {
                e && e._closestTab === this && (this._templateLabel = e)
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275cmp = h({
                type: n,
                selectors: [
                    ["mat-tab"]
                ],
                contentQueries: function(t, i, a) {
                    if (t & 1 && (ge(a, Xt, 5), ge(a, Da, 7, we)), t & 2) {
                        let d;
                        V(d = N()) && (i.templateLabel = d.first), V(d = N()) && (i._explicitContent = d.first)
                    }
                },
                viewQuery: function(t, i) {
                    if (t & 1 && G(we, 7), t & 2) {
                        let a;
                        V(a = N()) && (i._implicitContent = a.first)
                    }
                },
                hostAttrs: ["hidden", ""],
                inputs: {
                    disabled: [2, "disabled", "disabled", U],
                    textLabel: [0, "label", "textLabel"],
                    ariaLabel: [0, "aria-label", "ariaLabel"],
                    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
                    labelClass: "labelClass",
                    bodyClass: "bodyClass"
                },
                exportAs: ["matTab"],
                features: [xe([{
                    provide: Ni,
                    useExisting: n
                }]), ve],
                ngContentSelectors: Zt,
                decls: 1,
                vars: 0,
                template: function(t, i) {
                    t & 1 && (ue(), g(0, ba, 1, 0, "ng-template"))
                },
                encapsulation: 2
            })
        }
        return n
    })(),
    Qt = "mdc-tab-indicator--active",
    Fi = "mdc-tab-indicator--no-transition",
    Wt = class {
        _items;
        _currentItem;
        constructor(o) {
            this._items = o
        }
        hide() {
            this._items.forEach(o => o.deactivateInkBar()), this._currentItem = void 0
        }
        alignToElement(o) {
            let e = this._items.find(i => i.elementRef.nativeElement === o),
                t = this._currentItem;
            if (e !== t && (t ? .deactivateInkBar(), e)) {
                let i = t ? .elementRef.nativeElement.getBoundingClientRect ? .();
                e.activateInkBar(i), this._currentItem = e
            }
        }
    },
    Ra = (() => {
        class n {
            _elementRef = s(le);
            _inkBarElement;
            _inkBarContentElement;
            _fitToContent = !1;
            get fitInkBarToContent() {
                return this._fitToContent
            }
            set fitInkBarToContent(e) {
                this._fitToContent !== e && (this._fitToContent = e, this._inkBarElement && this._appendInkBarElement())
            }
            activateInkBar(e) {
                let t = this._elementRef.nativeElement;
                if (!e || !t.getBoundingClientRect || !this._inkBarContentElement) {
                    t.classList.add(Qt);
                    return
                }
                let i = t.getBoundingClientRect(),
                    a = e.width / i.width,
                    d = e.left - i.left;
                t.classList.add(Fi), this._inkBarContentElement.style.setProperty("transform", `translateX(${d}px) scaleX(${a})`), t.getBoundingClientRect(), t.classList.remove(Fi), t.classList.add(Qt), this._inkBarContentElement.style.setProperty("transform", "")
            }
            deactivateInkBar() {
                this._elementRef.nativeElement.classList.remove(Qt)
            }
            ngOnInit() {
                this._createInkBarElement()
            }
            ngOnDestroy() {
                this._inkBarElement ? .remove(), this._inkBarElement = this._inkBarContentElement = null
            }
            _createInkBarElement() {
                let e = this._elementRef.nativeElement.ownerDocument || document,
                    t = this._inkBarElement = e.createElement("span"),
                    i = this._inkBarContentElement = e.createElement("span");
                t.className = "mdc-tab-indicator", i.className = "mdc-tab-indicator__content mdc-tab-indicator__content--underline", t.appendChild(this._inkBarContentElement), this._appendInkBarElement()
            }
            _appendInkBarElement() {
                this._inkBarElement;
                let e = this._fitToContent ? this._elementRef.nativeElement.querySelector(".mdc-tab__content") : this._elementRef.nativeElement;
                e.appendChild(this._inkBarElement)
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275dir = te({
                type: n,
                inputs: {
                    fitInkBarToContent: [2, "fitInkBarToContent", "fitInkBarToContent", U]
                }
            })
        }
        return n
    })();
var Hi = (() => {
        class n extends Ra {
            elementRef = s(le);
            disabled = !1;
            focus() {
                this.elementRef.nativeElement.focus()
            }
            getOffsetLeft() {
                return this.elementRef.nativeElement.offsetLeft
            }
            getOffsetWidth() {
                return this.elementRef.nativeElement.offsetWidth
            }
            static\ u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })();
            static\ u0275dir = te({
                type: n,
                selectors: [
                    ["", "matTabLabelWrapper", ""]
                ],
                hostVars: 3,
                hostBindings: function(t, i) {
                    t & 2 && (k("aria-disabled", !!i.disabled), E("mat-mdc-tab-disabled", i.disabled))
                },
                inputs: {
                    disabled: [2, "disabled", "disabled", U]
                },
                features: [P]
            })
        }
        return n
    })(),
    Ai = {
        passive: !0
    },
    Ba = 650,
    Fa = 100,
    Aa = (() => {
        class n {
            _elementRef = s(le);
            _changeDetectorRef = s(be);
            _viewportRuler = s(Ci);
            _dir = s(je, {
                optional: !0
            });
            _ngZone = s(ye);
            _platform = s(Ht);
            _sharedResizeObserver = s(Bi);
            _injector = s(Ie);
            _renderer = s(ze);
            _animationMode = s(Le, {
                optional: !0
            });
            _eventCleanups;
            _scrollDistance = 0;
            _selectedIndexChanged = !1;
            _destroyed = new ee;
            _showPaginationControls = !1;
            _disableScrollAfter = !0;
            _disableScrollBefore = !0;
            _tabLabelCount;
            _scrollDistanceChanged;
            _keyManager;
            _currentTextContent;
            _stopScrolling = new ee;
            disablePagination = !1;
            get selectedIndex() {
                return this._selectedIndex
            }
            set selectedIndex(e) {
                let t = isNaN(e) ? 0 : e;
                this._selectedIndex != t && (this._selectedIndexChanged = !0, this._selectedIndex = t, this._keyManager && this._keyManager.updateActiveItem(t))
            }
            _selectedIndex = 0;
            selectFocusedIndex = new W;
            indexFocused = new W;
            constructor() {
                this._eventCleanups = this._ngZone.runOutsideAngular(() => [this._renderer.listen(this._elementRef.nativeElement, "mouseleave", () => this._stopInterval())])
            }
            ngAfterViewInit() {
                this._eventCleanups.push(Ue(this._renderer, this._previousPaginator.nativeElement, "touchstart", () => this._handlePaginatorPress("before"), Ai), Ue(this._renderer, this._nextPaginator.nativeElement, "touchstart", () => this._handlePaginatorPress("after"), Ai))
            }
            ngAfterContentInit() {
                let e = this._dir ? this._dir.change : Ve("ltr"),
                    t = this._sharedResizeObserver.observe(this._elementRef.nativeElement).pipe(cn(32), y(this._destroyed)),
                    i = this._viewportRuler.change(150).pipe(y(this._destroyed)),
                    a = () => {
                        this.updatePagination(), this._alignInkBarToSelectedTab()
                    };
                this._keyManager = new yt(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap().skipPredicate(() => !1), this._keyManager.updateActiveItem(this._selectedIndex), Oe(a, {
                    injector: this._injector
                }), fe(e, i, t, this._items.changes, this._itemsResized()).pipe(y(this._destroyed)).subscribe(() => {
                    this._ngZone.run(() => {
                        Promise.resolve().then(() => {
                            this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), this._scrollDistance)), a()
                        })
                    }), this._keyManager.withHorizontalOrientation(this._getLayoutDirection())
                }), this._keyManager.change.subscribe(d => {
                    this.indexFocused.emit(d), this._setTabFocus(d)
                })
            }
            _itemsResized() {
                return typeof ResizeObserver != "function" ? rn : this._items.changes.pipe(_e(this._items), Me(e => new Ge(t => this._ngZone.runOutsideAngular(() => {
                    let i = new ResizeObserver(a => t.next(a));
                    return e.forEach(a => i.observe(a.elementRef.nativeElement)), () => {
                        i.disconnect()
                    }
                }))), pn(1), ce(e => e.some(t => t.contentRect.width > 0 && t.contentRect.height > 0)))
            }
            ngAfterContentChecked() {
                this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck())
            }
            ngOnDestroy() {
                this._eventCleanups.forEach(e => e()), this._keyManager ? .destroy(), this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete()
            }
            _handleKeydown(e) {
                if (!vt(e)) switch (e.keyCode) {
                    case 13:
                    case 32:
                        if (this.focusIndex !== this.selectedIndex) {
                            let t = this._items.get(this.focusIndex);
                            t && !t.disabled && (this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(e))
                        }
                        break;
                    default:
                        this._keyManager.onKeydown(e)
                }
            }
            _onContentChanges() {
                let e = this._elementRef.nativeElement.textContent;
                e !== this._currentTextContent && (this._currentTextContent = e || "", this._ngZone.run(() => {
                    this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck()
                }))
            }
            updatePagination() {
                this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition()
            }
            get focusIndex() {
                return this._keyManager ? this._keyManager.activeItemIndex : 0
            }
            set focusIndex(e) {
                !this._isValidIndex(e) || this.focusIndex === e || !this._keyManager || this._keyManager.setActiveItem(e)
            }
            _isValidIndex(e) {
                return this._items ? !!this._items.toArray()[e] : !0
            }
            _setTabFocus(e) {
                if (this._showPaginationControls && this._scrollToLabel(e), this._items && this._items.length) {
                    this._items.toArray()[e].focus();
                    let t = this._tabListContainer.nativeElement;
                    this._getLayoutDirection() == "ltr" ? t.scrollLeft = 0 : t.scrollLeft = t.scrollWidth - t.offsetWidth
                }
            }
            _getLayoutDirection() {
                return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr"
            }
            _updateTabScrollPosition() {
                if (this.disablePagination) return;
                let e = this.scrollDistance,
                    t = this._getLayoutDirection() === "ltr" ? -e : e;
                this._tabList.nativeElement.style.transform = `translateX(${Math.round(t)}px)`, (this._platform.TRIDENT || this._platform.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0)
            }
            get scrollDistance() {
                return this._scrollDistance
            }
            set scrollDistance(e) {
                this._scrollTo(e)
            }
            _scrollHeader(e) {
                let t = this._tabListContainer.nativeElement.offsetWidth,
                    i = (e == "before" ? -1 : 1) * t / 3;
                return this._scrollTo(this._scrollDistance + i)
            }
            _handlePaginatorClick(e) {
                this._stopInterval(), this._scrollHeader(e)
            }
            _scrollToLabel(e) {
                if (this.disablePagination) return;
                let t = this._items ? this._items.toArray()[e] : null;
                if (!t) return;
                let i = this._tabListContainer.nativeElement.offsetWidth,
                    {
                        offsetLeft: a,
                        offsetWidth: d
                    } = t.elementRef.nativeElement,
                    S, L;
                this._getLayoutDirection() == "ltr" ? (S = a, L = S + d) : (L = this._tabListInner.nativeElement.offsetWidth - a, S = L - d);
                let X = this.scrollDistance,
                    J = this.scrollDistance + i;
                S < X ? this.scrollDistance -= X - S : L > J && (this.scrollDistance += Math.min(L - J, S - X))
            }
            _checkPaginationEnabled() {
                if (this.disablePagination) this._showPaginationControls = !1;
                else {
                    let e = this._tabListInner.nativeElement.scrollWidth,
                        t = this._elementRef.nativeElement.offsetWidth,
                        i = e - t >= 5;
                    i || (this.scrollDistance = 0), i !== this._showPaginationControls && (this._showPaginationControls = i, this._changeDetectorRef.markForCheck())
                }
            }
            _checkScrollingControls() {
                this.disablePagination ? this._disableScrollAfter = this._disableScrollBefore = !0 : (this._disableScrollBefore = this.scrollDistance == 0, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), this._changeDetectorRef.markForCheck())
            }
            _getMaxScrollDistance() {
                let e = this._tabListInner.nativeElement.scrollWidth,
                    t = this._tabListContainer.nativeElement.offsetWidth;
                return e - t || 0
            }
            _alignInkBarToSelectedTab() {
                let e = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null,
                    t = e ? e.elementRef.nativeElement : null;
                t ? this._inkBar.alignToElement(t) : this._inkBar.hide()
            }
            _stopInterval() {
                this._stopScrolling.next()
            }
            _handlePaginatorPress(e, t) {
                t && t.button != null && t.button !== 0 || (this._stopInterval(), sn(Ba, Fa).pipe(y(fe(this._stopScrolling, this._destroyed))).subscribe(() => {
                    let {
                        maxScrollDistance: i,
                        distance: a
                    } = this._scrollHeader(e);
                    (a === 0 || a >= i) && this._stopInterval()
                }))
            }
            _scrollTo(e) {
                if (this.disablePagination) return {
                    maxScrollDistance: 0,
                    distance: 0
                };
                let t = this._getMaxScrollDistance();
                return this._scrollDistance = Math.max(0, Math.min(t, e)), this._scrollDistanceChanged = !0, this._checkScrollingControls(), {
                    maxScrollDistance: t,
                    distance: this._scrollDistance
                }
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275dir = te({
                type: n,
                inputs: {
                    disablePagination: [2, "disablePagination", "disablePagination", U],
                    selectedIndex: [2, "selectedIndex", "selectedIndex", tt]
                },
                outputs: {
                    selectFocusedIndex: "selectFocusedIndex",
                    indexFocused: "indexFocused"
                }
            })
        }
        return n
    })(),
    Va = (() => {
        class n extends Aa {
            _items;
            _tabListContainer;
            _tabList;
            _tabListInner;
            _nextPaginator;
            _previousPaginator;
            _inkBar;
            ariaLabel;
            ariaLabelledby;
            disableRipple = !1;
            ngAfterContentInit() {
                this._inkBar = new Wt(this._items), super.ngAfterContentInit()
            }
            _itemSelected(e) {
                e.preventDefault()
            }
            static\ u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })();
            static\ u0275cmp = h({
                type: n,
                selectors: [
                    ["mat-tab-header"]
                ],
                contentQueries: function(t, i, a) {
                    if (t & 1 && ge(a, Hi, 4), t & 2) {
                        let d;
                        V(d = N()) && (i._items = d)
                    }
                },
                viewQuery: function(t, i) {
                    if (t & 1 && (G(ha, 7), G(fa, 7), G(_a, 7), G(va, 5), G(ya, 5)), t & 2) {
                        let a;
                        V(a = N()) && (i._tabListContainer = a.first), V(a = N()) && (i._tabList = a.first), V(a = N()) && (i._tabListInner = a.first), V(a = N()) && (i._nextPaginator = a.first), V(a = N()) && (i._previousPaginator = a.first)
                    }
                },
                hostAttrs: [1, "mat-mdc-tab-header"],
                hostVars: 4,
                hostBindings: function(t, i) {
                    t & 2 && E("mat-mdc-tab-header-pagination-controls-enabled", i._showPaginationControls)("mat-mdc-tab-header-rtl", i._getLayoutDirection() == "rtl")
                },
                inputs: {
                    ariaLabel: [0, "aria-label", "ariaLabel"],
                    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
                    disableRipple: [2, "disableRipple", "disableRipple", U]
                },
                features: [P],
                ngContentSelectors: Zt,
                decls: 13,
                vars: 10,
                consts: [
                    ["previousPaginator", ""],
                    ["tabListContainer", ""],
                    ["tabList", ""],
                    ["tabListInner", ""],
                    ["nextPaginator", ""],
                    ["mat-ripple", "", 1, "mat-mdc-tab-header-pagination", "mat-mdc-tab-header-pagination-before", 3, "click", "mousedown", "touchend", "matRippleDisabled"],
                    [1, "mat-mdc-tab-header-pagination-chevron"],
                    [1, "mat-mdc-tab-label-container", 3, "keydown"],
                    ["role", "tablist", 1, "mat-mdc-tab-list", 3, "cdkObserveContent"],
                    [1, "mat-mdc-tab-labels"],
                    ["mat-ripple", "", 1, "mat-mdc-tab-header-pagination", "mat-mdc-tab-header-pagination-after", 3, "mousedown", "click", "touchend", "matRippleDisabled"]
                ],
                template: function(t, i) {
                    if (t & 1) {
                        let a = w();
                        ue(), l(0, "div", 5, 0), v("click", function() {
                            return f(a), _(i._handlePaginatorClick("before"))
                        })("mousedown", function(S) {
                            return f(a), _(i._handlePaginatorPress("before", S))
                        })("touchend", function() {
                            return f(a), _(i._stopInterval())
                        }), u(2, "div", 6), p(), l(3, "div", 7, 1), v("keydown", function(S) {
                            return f(a), _(i._handleKeydown(S))
                        }), l(5, "div", 8, 2), v("cdkObserveContent", function() {
                            return f(a), _(i._onContentChanges())
                        }), l(7, "div", 9, 3), pe(9), p()()(), l(10, "div", 10, 4), v("mousedown", function(S) {
                            return f(a), _(i._handlePaginatorPress("after", S))
                        })("click", function() {
                            return f(a), _(i._handlePaginatorClick("after"))
                        })("touchend", function() {
                            return f(a), _(i._stopInterval())
                        }), u(12, "div", 6), p()
                    }
                    t & 2 && (E("mat-mdc-tab-header-pagination-disabled", i._disableScrollBefore), m("matRippleDisabled", i._disableScrollBefore || i.disableRipple), c(3), E("_mat-animation-noopable", i._animationMode === "NoopAnimations"), c(2), k("aria-label", i.ariaLabel || null)("aria-labelledby", i.ariaLabelledby || null), c(5), E("mat-mdc-tab-header-pagination-disabled", i._disableScrollAfter), m("matRippleDisabled", i._disableScrollAfter || i.disableRipple))
                },
                dependencies: [Qe, Ut],
                styles: [".mat-mdc-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mdc-tab-indicator .mdc-tab-indicator__content{transition-duration:var(--mat-tab-animation-duration, 250ms)}.mat-mdc-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0);touch-action:none;box-sizing:content-box;outline:0}.mat-mdc-tab-header-pagination::-moz-focus-inner{border:0}.mat-mdc-tab-header-pagination .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab-header-pagination-controls-enabled .mat-mdc-tab-header-pagination{display:flex}.mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after{padding-left:4px}.mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-pagination-after{padding-right:4px}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-mdc-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px;border-color:var(--mat-tab-header-pagination-icon-color, var(--mat-sys-on-surface))}.mat-mdc-tab-header-pagination-disabled{box-shadow:none;cursor:default;pointer-events:none}.mat-mdc-tab-header-pagination-disabled .mat-mdc-tab-header-pagination-chevron{opacity:.4}.mat-mdc-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-mdc-tab-list{transition:none}.mat-mdc-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1;border-bottom-style:solid;border-bottom-width:var(--mat-tab-header-divider-height, 1px);border-bottom-color:var(--mat-tab-header-divider-color, var(--mat-sys-surface-variant))}.mat-mdc-tab-group-inverted-header .mat-mdc-tab-label-container{border-bottom:none;border-top-style:solid;border-top-width:var(--mat-tab-header-divider-height, 1px);border-top-color:var(--mat-tab-header-divider-color, var(--mat-sys-surface-variant))}.mat-mdc-tab-labels{display:flex;flex:1 0 auto}[mat-align-tabs=center]>.mat-mdc-tab-header .mat-mdc-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-mdc-tab-header .mat-mdc-tab-labels{justify-content:flex-end}.cdk-drop-list .mat-mdc-tab-labels,.mat-mdc-tab-labels.cdk-drop-list{min-height:var(--mdc-secondary-navigation-tab-container-height, 48px)}.mat-mdc-tab::before{margin:5px}@media(forced-colors: active){.mat-mdc-tab[aria-disabled=true]{color:GrayText}}"],
                encapsulation: 2
            })
        }
        return n
    })(),
    Na = new se("MAT_TABS_CONFIG"),
    Vi = (() => {
        class n extends jt {
            _host = s(qt);
            _centeringSub = re.EMPTY;
            _leavingSub = re.EMPTY;
            constructor() {
                super()
            }
            ngOnInit() {
                super.ngOnInit(), this._centeringSub = this._host._beforeCentering.pipe(_e(this._host._isCenterPosition())).subscribe(e => {
                    this._host._content && e && !this.hasAttached() && this.attach(this._host._content)
                }), this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {
                    this._host.preserveContent || this.detach()
                })
            }
            ngOnDestroy() {
                super.ngOnDestroy(), this._centeringSub.unsubscribe(), this._leavingSub.unsubscribe()
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275dir = te({
                type: n,
                selectors: [
                    ["", "matTabBodyHost", ""]
                ],
                features: [P]
            })
        }
        return n
    })(),
    qt = (() => {
        class n {
            _elementRef = s(le);
            _dir = s(je, {
                optional: !0
            });
            _ngZone = s(ye);
            _injector = s(Ie);
            _renderer = s(ze);
            _animationsModule = s(Le, {
                optional: !0
            });
            _eventCleanups;
            _initialized;
            _fallbackTimer;
            _positionIndex;
            _dirChangeSubscription = re.EMPTY;
            _position;
            _previousPosition;
            _onCentering = new W;
            _beforeCentering = new W;
            _afterLeavingCenter = new W;
            _onCentered = new W(!0);
            _portalHost;
            _contentElement;
            _content;
            animationDuration = "500ms";
            preserveContent = !1;
            set position(e) {
                this._positionIndex = e, this._computePositionAnimationState()
            }
            constructor() {
                if (this._dir) {
                    let e = s(be);
                    this._dirChangeSubscription = this._dir.change.subscribe(t => {
                        this._computePositionAnimationState(t), e.markForCheck()
                    })
                }
            }
            ngOnInit() {
                this._bindTransitionEvents(), this._position === "center" && (this._setActiveClass(!0), Oe(() => this._onCentering.emit(this._elementRef.nativeElement.clientHeight), {
                    injector: this._injector
                })), this._initialized = !0
            }
            ngOnDestroy() {
                clearTimeout(this._fallbackTimer), this._eventCleanups ? .forEach(e => e()), this._dirChangeSubscription.unsubscribe()
            }
            _bindTransitionEvents() {
                this._ngZone.runOutsideAngular(() => {
                    let e = this._elementRef.nativeElement,
                        t = i => {
                            i.target === this._contentElement ? .nativeElement && (this._elementRef.nativeElement.classList.remove("mat-tab-body-animating"), i.type === "transitionend" && this._transitionDone())
                        };
                    this._eventCleanups = [this._renderer.listen(e, "transitionstart", i => {
                        i.target === this._contentElement ? .nativeElement && (this._elementRef.nativeElement.classList.add("mat-tab-body-animating"), this._transitionStarted())
                    }), this._renderer.listen(e, "transitionend", t), this._renderer.listen(e, "transitioncancel", t)]
                })
            }
            _transitionStarted() {
                clearTimeout(this._fallbackTimer);
                let e = this._position === "center";
                this._beforeCentering.emit(e), e && this._onCentering.emit(this._elementRef.nativeElement.clientHeight)
            }
            _transitionDone() {
                this._position === "center" ? this._onCentered.emit() : this._previousPosition === "center" && this._afterLeavingCenter.emit()
            }
            _setActiveClass(e) {
                this._elementRef.nativeElement.classList.toggle("mat-mdc-tab-body-active", e)
            }
            _getLayoutDirection() {
                return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr"
            }
            _isCenterPosition() {
                return this._positionIndex === 0
            }
            _computePositionAnimationState(e = this._getLayoutDirection()) {
                this._previousPosition = this._position, this._positionIndex < 0 ? this._position = e == "ltr" ? "left" : "right" : this._positionIndex > 0 ? this._position = e == "ltr" ? "right" : "left" : this._position = "center", this._animationsDisabled() ? this._simulateTransitionEvents() : this._initialized && (this._position === "center" || this._previousPosition === "center") && (clearTimeout(this._fallbackTimer), this._fallbackTimer = this._ngZone.runOutsideAngular(() => setTimeout(() => this._simulateTransitionEvents(), 100)))
            }
            _simulateTransitionEvents() {
                this._transitionStarted(), Oe(() => this._transitionDone(), {
                    injector: this._injector
                })
            }
            _animationsDisabled() {
                return this._animationsModule === "NoopAnimations" || this.animationDuration === "0ms" || this.animationDuration === "0s"
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275cmp = h({
                type: n,
                selectors: [
                    ["mat-tab-body"]
                ],
                viewQuery: function(t, i) {
                    if (t & 1 && (G(Vi, 5), G(Ca, 5)), t & 2) {
                        let a;
                        V(a = N()) && (i._portalHost = a.first), V(a = N()) && (i._contentElement = a.first)
                    }
                },
                hostAttrs: [1, "mat-mdc-tab-body"],
                hostVars: 1,
                hostBindings: function(t, i) {
                    t & 2 && k("inert", i._position === "center" ? null : "")
                },
                inputs: {
                    _content: [0, "content", "_content"],
                    animationDuration: "animationDuration",
                    preserveContent: "preserveContent",
                    position: "position"
                },
                outputs: {
                    _onCentering: "_onCentering",
                    _beforeCentering: "_beforeCentering",
                    _onCentered: "_onCentered"
                },
                decls: 3,
                vars: 6,
                consts: [
                    ["content", ""],
                    ["cdkScrollable", "", 1, "mat-mdc-tab-body-content"],
                    ["matTabBodyHost", ""]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "div", 1, 0), g(2, xa, 0, 0, "ng-template", 2), p()), t & 2 && E("mat-tab-body-content-left", i._position === "left")("mat-tab-body-content-right", i._position === "right")("mat-tab-body-content-can-animate", i._position === "center" || i._previousPosition === "center")
                },
                dependencies: [Vi, yi],
                styles: [".mat-mdc-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;outline:0;flex-basis:100%}.mat-mdc-tab-body.mat-mdc-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-mdc-tab-group.mat-mdc-tab-group-dynamic-height .mat-mdc-tab-body.mat-mdc-tab-body-active{overflow-y:hidden}.mat-mdc-tab-body-content{height:100%;overflow:auto;transform:none;visibility:hidden}.mat-tab-body-animating>.mat-mdc-tab-body-content,.mat-mdc-tab-body-active>.mat-mdc-tab-body-content{visibility:visible}.mat-mdc-tab-group-dynamic-height .mat-mdc-tab-body-content{overflow:hidden}.mat-tab-body-content-can-animate{transition:transform var(--mat-tab-animation-duration) 1ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-mdc-tab-body-wrapper._mat-animation-noopable .mat-tab-body-content-can-animate{transition:none}.mat-tab-body-content-left{transform:translate3d(-100%, 0, 0)}.mat-tab-body-content-right{transform:translate3d(100%, 0, 0)}"],
                encapsulation: 2
            })
        }
        return n
    })(),
    Ui = (() => {
        class n {
            _elementRef = s(le);
            _changeDetectorRef = s(be);
            _ngZone = s(ye);
            _tabsSubscription = re.EMPTY;
            _tabLabelSubscription = re.EMPTY;
            _tabBodySubscription = re.EMPTY;
            _animationMode = s(Le, {
                optional: !0
            });
            _allTabs;
            _tabBodies;
            _tabBodyWrapper;
            _tabHeader;
            _tabs = new Ke;
            _indexToSelect = 0;
            _lastFocusedTabIndex = null;
            _tabBodyWrapperHeight = 0;
            color;
            get fitInkBarToContent() {
                return this._fitInkBarToContent
            }
            set fitInkBarToContent(e) {
                this._fitInkBarToContent = e, this._changeDetectorRef.markForCheck()
            }
            _fitInkBarToContent = !1;
            stretchTabs = !0;
            alignTabs = null;
            dynamicHeight = !1;
            get selectedIndex() {
                return this._selectedIndex
            }
            set selectedIndex(e) {
                this._indexToSelect = isNaN(e) ? null : e
            }
            _selectedIndex = null;
            headerPosition = "above";
            get animationDuration() {
                return this._animationDuration
            }
            set animationDuration(e) {
                let t = e + "";
                this._animationDuration = /^\d+$/.test(t) ? e + "ms" : t
            }
            _animationDuration;
            get contentTabIndex() {
                return this._contentTabIndex
            }
            set contentTabIndex(e) {
                this._contentTabIndex = isNaN(e) ? null : e
            }
            _contentTabIndex;
            disablePagination = !1;
            disableRipple = !1;
            preserveContent = !1;
            get backgroundColor() {
                return this._backgroundColor
            }
            set backgroundColor(e) {
                let t = this._elementRef.nativeElement.classList;
                t.remove("mat-tabs-with-background", `mat-background-${this.backgroundColor}`), e && t.add("mat-tabs-with-background", `mat-background-${e}`), this._backgroundColor = e
            }
            _backgroundColor;
            ariaLabel;
            ariaLabelledby;
            selectedIndexChange = new W;
            focusChange = new W;
            animationDone = new W;
            selectedTabChange = new W(!0);
            _groupId;
            _isServer = !s(Ht).isBrowser;
            constructor() {
                let e = s(Na, {
                    optional: !0
                });
                this._groupId = s(_t).getId("mat-tab-group-"), this.animationDuration = e && e.animationDuration ? e.animationDuration : "500ms", this.disablePagination = e && e.disablePagination != null ? e.disablePagination : !1, this.dynamicHeight = e && e.dynamicHeight != null ? e.dynamicHeight : !1, e ? .contentTabIndex != null && (this.contentTabIndex = e.contentTabIndex), this.preserveContent = !!e ? .preserveContent, this.fitInkBarToContent = e && e.fitInkBarToContent != null ? e.fitInkBarToContent : !1, this.stretchTabs = e && e.stretchTabs != null ? e.stretchTabs : !0, this.alignTabs = e && e.alignTabs != null ? e.alignTabs : null
            }
            ngAfterContentChecked() {
                let e = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
                if (this._selectedIndex != e) {
                    let t = this._selectedIndex == null;
                    if (!t) {
                        this.selectedTabChange.emit(this._createChangeEvent(e));
                        let i = this._tabBodyWrapper.nativeElement;
                        i.style.minHeight = i.clientHeight + "px"
                    }
                    Promise.resolve().then(() => {
                        this._tabs.forEach((i, a) => i.isActive = a === e), t || (this.selectedIndexChange.emit(e), this._tabBodyWrapper.nativeElement.style.minHeight = "")
                    })
                }
                this._tabs.forEach((t, i) => {
                    t.position = i - e, this._selectedIndex != null && t.position == 0 && !t.origin && (t.origin = e - this._selectedIndex)
                }), this._selectedIndex !== e && (this._selectedIndex = e, this._lastFocusedTabIndex = null, this._changeDetectorRef.markForCheck())
            }
            ngAfterContentInit() {
                this._subscribeToAllTabChanges(), this._subscribeToTabLabels(), this._tabsSubscription = this._tabs.changes.subscribe(() => {
                    let e = this._clampTabIndex(this._indexToSelect);
                    if (e === this._selectedIndex) {
                        let t = this._tabs.toArray(),
                            i;
                        for (let a = 0; a < t.length; a++)
                            if (t[a].isActive) {
                                this._indexToSelect = this._selectedIndex = a, this._lastFocusedTabIndex = null, i = t[a];
                                break
                            }!i && t[e] && Promise.resolve().then(() => {
                            t[e].isActive = !0, this.selectedTabChange.emit(this._createChangeEvent(e))
                        })
                    }
                    this._changeDetectorRef.markForCheck()
                })
            }
            ngAfterViewInit() {
                this._tabBodySubscription = this._tabBodies.changes.subscribe(() => this._bodyCentered(!0))
            }
            _subscribeToAllTabChanges() {
                this._allTabs.changes.pipe(_e(this._allTabs)).subscribe(e => {
                    this._tabs.reset(e.filter(t => t._closestTabGroup === this || !t._closestTabGroup)), this._tabs.notifyOnChanges()
                })
            }
            ngOnDestroy() {
                this._tabs.destroy(), this._tabsSubscription.unsubscribe(), this._tabLabelSubscription.unsubscribe(), this._tabBodySubscription.unsubscribe()
            }
            realignInkBar() {
                this._tabHeader && this._tabHeader._alignInkBarToSelectedTab()
            }
            updatePagination() {
                this._tabHeader && this._tabHeader.updatePagination()
            }
            focusTab(e) {
                let t = this._tabHeader;
                t && (t.focusIndex = e)
            }
            _focusChanged(e) {
                this._lastFocusedTabIndex = e, this.focusChange.emit(this._createChangeEvent(e))
            }
            _createChangeEvent(e) {
                let t = new Gt;
                return t.index = e, this._tabs && this._tabs.length && (t.tab = this._tabs.toArray()[e]), t
            }
            _subscribeToTabLabels() {
                this._tabLabelSubscription && this._tabLabelSubscription.unsubscribe(), this._tabLabelSubscription = fe(...this._tabs.map(e => e._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck())
            }
            _clampTabIndex(e) {
                return Math.min(this._tabs.length - 1, Math.max(e || 0, 0))
            }
            _getTabLabelId(e) {
                return `${this._groupId}-label-${e}`
            }
            _getTabContentId(e) {
                return `${this._groupId}-content-${e}`
            }
            _setTabBodyWrapperHeight(e) {
                if (!this.dynamicHeight || !this._tabBodyWrapperHeight) {
                    this._tabBodyWrapperHeight = e;
                    return
                }
                let t = this._tabBodyWrapper.nativeElement;
                t.style.height = this._tabBodyWrapperHeight + "px", this._tabBodyWrapper.nativeElement.offsetHeight && (t.style.height = e + "px")
            }
            _removeTabBodyWrapperHeight() {
                let e = this._tabBodyWrapper.nativeElement;
                this._tabBodyWrapperHeight = e.clientHeight, e.style.height = "", this._ngZone.run(() => this.animationDone.emit())
            }
            _handleClick(e, t, i) {
                t.focusIndex = i, e.disabled || (this.selectedIndex = i)
            }
            _getTabIndex(e) {
                let t = this._lastFocusedTabIndex ? ? this.selectedIndex;
                return e === t ? 0 : -1
            }
            _tabFocusChanged(e, t) {
                e && e !== "mouse" && e !== "touch" && (this._tabHeader.focusIndex = t)
            }
            _bodyCentered(e) {
                e && this._tabBodies ? .forEach((t, i) => t._setActiveClass(i === this._selectedIndex))
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275cmp = h({
                type: n,
                selectors: [
                    ["mat-tab-group"]
                ],
                contentQueries: function(t, i, a) {
                    if (t & 1 && ge(a, Jt, 5), t & 2) {
                        let d;
                        V(d = N()) && (i._allTabs = d)
                    }
                },
                viewQuery: function(t, i) {
                    if (t & 1 && (G(ka, 5), G(Ma, 5), G(qt, 5)), t & 2) {
                        let a;
                        V(a = N()) && (i._tabBodyWrapper = a.first), V(a = N()) && (i._tabHeader = a.first), V(a = N()) && (i._tabBodies = a)
                    }
                },
                hostAttrs: [1, "mat-mdc-tab-group"],
                hostVars: 11,
                hostBindings: function(t, i) {
                    t & 2 && (k("mat-align-tabs", i.alignTabs), Ce("mat-" + (i.color || "primary")), fn("--mat-tab-animation-duration", i.animationDuration), E("mat-mdc-tab-group-dynamic-height", i.dynamicHeight)("mat-mdc-tab-group-inverted-header", i.headerPosition === "below")("mat-mdc-tab-group-stretch-tabs", i.stretchTabs))
                },
                inputs: {
                    color: "color",
                    fitInkBarToContent: [2, "fitInkBarToContent", "fitInkBarToContent", U],
                    stretchTabs: [2, "mat-stretch-tabs", "stretchTabs", U],
                    alignTabs: [0, "mat-align-tabs", "alignTabs"],
                    dynamicHeight: [2, "dynamicHeight", "dynamicHeight", U],
                    selectedIndex: [2, "selectedIndex", "selectedIndex", tt],
                    headerPosition: "headerPosition",
                    animationDuration: "animationDuration",
                    contentTabIndex: [2, "contentTabIndex", "contentTabIndex", tt],
                    disablePagination: [2, "disablePagination", "disablePagination", U],
                    disableRipple: [2, "disableRipple", "disableRipple", U],
                    preserveContent: [2, "preserveContent", "preserveContent", U],
                    backgroundColor: "backgroundColor",
                    ariaLabel: [0, "aria-label", "ariaLabel"],
                    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"]
                },
                outputs: {
                    selectedIndexChange: "selectedIndexChange",
                    focusChange: "focusChange",
                    animationDone: "animationDone",
                    selectedTabChange: "selectedTabChange"
                },
                exportAs: ["matTabGroup"],
                features: [xe([{
                    provide: zi,
                    useExisting: n
                }])],
                ngContentSelectors: Zt,
                decls: 9,
                vars: 8,
                consts: [
                    ["tabHeader", ""],
                    ["tabBodyWrapper", ""],
                    ["tabNode", ""],
                    [3, "indexFocused", "selectFocusedIndex", "selectedIndex", "disableRipple", "disablePagination", "aria-label", "aria-labelledby"],
                    ["role", "tab", "matTabLabelWrapper", "", "cdkMonitorElementFocus", "", 1, "mdc-tab", "mat-mdc-tab", "mat-focus-indicator", 3, "id", "mdc-tab--active", "class", "disabled", "fitInkBarToContent"],
                    [1, "mat-mdc-tab-body-wrapper"],
                    ["role", "tabpanel", 3, "id", "class", "content", "position", "animationDuration", "preserveContent"],
                    ["role", "tab", "matTabLabelWrapper", "", "cdkMonitorElementFocus", "", 1, "mdc-tab", "mat-mdc-tab", "mat-focus-indicator", 3, "click", "cdkFocusChange", "id", "disabled", "fitInkBarToContent"],
                    [1, "mdc-tab__ripple"],
                    ["mat-ripple", "", 1, "mat-mdc-tab-ripple", 3, "matRippleTrigger", "matRippleDisabled"],
                    [1, "mdc-tab__content"],
                    [1, "mdc-tab__text-label"],
                    [3, "cdkPortalOutlet"],
                    ["role", "tabpanel", 3, "_onCentered", "_onCentering", "_beforeCentering", "id", "content", "position", "animationDuration", "preserveContent"]
                ],
                template: function(t, i) {
                    if (t & 1) {
                        let a = w();
                        ue(), l(0, "mat-tab-header", 3, 0), v("indexFocused", function(S) {
                            return f(a), _(i._focusChanged(S))
                        })("selectFocusedIndex", function(S) {
                            return f(a), _(i.selectedIndex = S)
                        }), ne(2, Pa, 8, 17, "div", 4, de), p(), g(4, Ia, 1, 0), l(5, "div", 5, 1), ne(7, La, 1, 10, "mat-tab-body", 6, de), p()
                    }
                    t & 2 && (m("selectedIndex", i.selectedIndex || 0)("disableRipple", i.disableRipple)("disablePagination", i.disablePagination)("aria-label", i.ariaLabel)("aria-labelledby", i.ariaLabelledby), c(2), ie(i._tabs), c(2), b(i._isServer ? 4 : -1), c(), E("_mat-animation-noopable", i._animationMode === "NoopAnimations"), c(2), ie(i._tabs))
                },
                dependencies: [Va, Hi, vi, Qe, jt, qt],
                styles: ['.mdc-tab{min-width:90px;padding:0 24px;display:flex;flex:1 0 auto;justify-content:center;box-sizing:border-box;border:none;outline:none;text-align:center;white-space:nowrap;cursor:pointer;z-index:1}.mdc-tab__content{display:flex;align-items:center;justify-content:center;height:inherit;pointer-events:none}.mdc-tab__text-label{transition:150ms color linear;display:inline-block;line-height:1;z-index:2}.mdc-tab--active .mdc-tab__text-label{transition-delay:100ms}._mat-animation-noopable .mdc-tab__text-label{transition:none}.mdc-tab-indicator{display:flex;position:absolute;top:0;left:0;justify-content:center;width:100%;height:100%;pointer-events:none;z-index:1}.mdc-tab-indicator__content{transition:var(--mat-tab-animation-duration, 250ms) transform cubic-bezier(0.4, 0, 0.2, 1);transform-origin:left;opacity:0}.mdc-tab-indicator__content--underline{align-self:flex-end;box-sizing:border-box;width:100%;border-top-style:solid}.mdc-tab-indicator--active .mdc-tab-indicator__content{opacity:1}._mat-animation-noopable .mdc-tab-indicator__content,.mdc-tab-indicator--no-transition .mdc-tab-indicator__content{transition:none}.mat-mdc-tab-ripple.mat-mdc-tab-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-mdc-tab{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-decoration:none;background:none;height:var(--mdc-secondary-navigation-tab-container-height, 48px);font-family:var(--mat-tab-header-label-text-font, var(--mat-sys-title-small-font));font-size:var(--mat-tab-header-label-text-size, var(--mat-sys-title-small-size));letter-spacing:var(--mat-tab-header-label-text-tracking, var(--mat-sys-title-small-tracking));line-height:var(--mat-tab-header-label-text-line-height, var(--mat-sys-title-small-line-height));font-weight:var(--mat-tab-header-label-text-weight, var(--mat-sys-title-small-weight))}.mat-mdc-tab.mdc-tab{flex-grow:0}.mat-mdc-tab .mdc-tab-indicator__content--underline{border-color:var(--mdc-tab-indicator-active-indicator-color, var(--mat-sys-primary));border-top-width:var(--mdc-tab-indicator-active-indicator-height, 2px);border-radius:var(--mdc-tab-indicator-active-indicator-shape, 0)}.mat-mdc-tab:hover .mdc-tab__text-label{color:var(--mat-tab-header-inactive-hover-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab:focus .mdc-tab__text-label{color:var(--mat-tab-header-inactive-focus-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active .mdc-tab__text-label{color:var(--mat-tab-header-active-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active .mdc-tab__ripple::before,.mat-mdc-tab.mdc-tab--active .mat-ripple-element{background-color:var(--mat-tab-header-active-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active:hover .mdc-tab__text-label{color:var(--mat-tab-header-active-hover-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active:hover .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-hover-indicator-color, var(--mat-sys-primary))}.mat-mdc-tab.mdc-tab--active:focus .mdc-tab__text-label{color:var(--mat-tab-header-active-focus-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-tab.mdc-tab--active:focus .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-focus-indicator-color, var(--mat-sys-primary))}.mat-mdc-tab.mat-mdc-tab-disabled{opacity:.4;pointer-events:none}.mat-mdc-tab.mat-mdc-tab-disabled .mdc-tab__content{pointer-events:none}.mat-mdc-tab.mat-mdc-tab-disabled .mdc-tab__ripple::before,.mat-mdc-tab.mat-mdc-tab-disabled .mat-ripple-element{background-color:var(--mat-tab-header-disabled-ripple-color)}.mat-mdc-tab .mdc-tab__ripple::before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;opacity:0;pointer-events:none;background-color:var(--mat-tab-header-inactive-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab .mdc-tab__text-label{color:var(--mat-tab-header-inactive-label-text-color, var(--mat-sys-on-surface));display:inline-flex;align-items:center}.mat-mdc-tab .mdc-tab__content{position:relative;pointer-events:auto}.mat-mdc-tab:hover .mdc-tab__ripple::before{opacity:.04}.mat-mdc-tab.cdk-program-focused .mdc-tab__ripple::before,.mat-mdc-tab.cdk-keyboard-focused .mdc-tab__ripple::before{opacity:.12}.mat-mdc-tab .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-tab-group.mat-mdc-tab-group-stretch-tabs>.mat-mdc-tab-header .mat-mdc-tab{flex-grow:1}.mat-mdc-tab-group{display:flex;flex-direction:column;max-width:100%}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination{background-color:var(--mat-tab-header-with-background-background-color)}.mat-mdc-tab-group.mat-tabs-with-background.mat-primary>.mat-mdc-tab-header .mat-mdc-tab .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background.mat-primary>.mat-mdc-tab-header .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-header .mat-mdc-tab:not(.mdc-tab--active) .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-header .mat-mdc-tab:not(.mdc-tab--active) .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-focus-indicator::before,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-focus-indicator::before{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-ripple-element,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mdc-tab__ripple::before,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-ripple-element,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mdc-tab__ripple::before{background-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-group.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-group.mat-mdc-tab-group-inverted-header{flex-direction:column-reverse}.mat-mdc-tab-group.mat-mdc-tab-group-inverted-header .mdc-tab-indicator__content--underline{align-self:flex-start}.mat-mdc-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-mdc-tab-body-wrapper._mat-animation-noopable{transition:none !important;animation:none !important}'],
                encapsulation: 2
            })
        }
        return n
    })(),
    Gt = class {
        index;
        tab
    };
var ji = (() => {
    class n {
        static\ u0275fac = function(t) {
            return new(t || n)
        };
        static\ u0275mod = Xe({
            type: n
        });
        static\ u0275inj = Ye({
            imports: [Re, Re]
        })
    }
    return n
})();
var $a = ["mat-menu-item", ""],
    Qa = [
        [
            ["mat-icon"],
            ["", "matMenuItemIcon", ""]
        ], "*"
    ],
    Wa = ["mat-icon, [matMenuItemIcon]", "*"];

function qa(n, o) {
    n & 1 && (gn(), l(0, "svg", 2), u(1, "polygon", 3), p())
}
var Ga = ["*"];

function Ya(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "div", 0), v("click", function() {
            f(e);
            let i = r();
            return _(i.closed.emit("click"))
        })("animationstart", function(i) {
            f(e);
            let a = r();
            return _(a._onAnimationStart(i.animationName))
        })("animationend", function(i) {
            f(e);
            let a = r();
            return _(a._onAnimationDone(i.animationName))
        })("animationcancel", function(i) {
            f(e);
            let a = r();
            return _(a._onAnimationDone(i.animationName))
        }), l(1, "div", 1), pe(2), p()()
    }
    if (n & 2) {
        let e = r();
        Ce(e._classList), E("mat-menu-panel-animations-disabled", e._animationsDisabled)("mat-menu-panel-exit-animation", e._panelAnimationState === "void")("mat-menu-panel-animating", e._isAnimating), m("id", e.panelId), k("aria-label", e.ariaLabel || null)("aria-labelledby", e.ariaLabelledby || null)("aria-describedby", e.ariaDescribedby || null)
    }
}
var tn = new se("MAT_MENU_PANEL"),
    qe = (() => {
        class n {
            _elementRef = s(le);
            _document = s(Nt);
            _focusMonitor = s(bt);
            _parentMenu = s(tn, {
                optional: !0
            });
            _changeDetectorRef = s(be);
            role = "menuitem";
            disabled = !1;
            disableRipple = !1;
            _hovered = new ee;
            _focused = new ee;
            _highlighted = !1;
            _triggersSubmenu = !1;
            constructor() {
                s(ht).load(Mt), this._parentMenu ? .addItem ? .(this)
            }
            focus(e, t) {
                this._focusMonitor && e ? this._focusMonitor.focusVia(this._getHostElement(), e, t) : this._getHostElement().focus(t), this._focused.next(this)
            }
            ngAfterViewInit() {
                this._focusMonitor && this._focusMonitor.monitor(this._elementRef, !1)
            }
            ngOnDestroy() {
                this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef), this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this), this._hovered.complete(), this._focused.complete()
            }
            _getTabIndex() {
                return this.disabled ? "-1" : "0"
            }
            _getHostElement() {
                return this._elementRef.nativeElement
            }
            _checkDisabled(e) {
                this.disabled && (e.preventDefault(), e.stopPropagation())
            }
            _handleMouseEnter() {
                this._hovered.next(this)
            }
            getLabel() {
                let e = this._elementRef.nativeElement.cloneNode(!0),
                    t = e.querySelectorAll("mat-icon, .material-icons");
                for (let i = 0; i < t.length; i++) t[i].remove();
                return e.textContent ? .trim() || ""
            }
            _setHighlighted(e) {
                this._highlighted = e, this._changeDetectorRef.markForCheck()
            }
            _setTriggersSubmenu(e) {
                this._triggersSubmenu = e, this._changeDetectorRef.markForCheck()
            }
            _hasFocus() {
                return this._document && this._document.activeElement === this._getHostElement()
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275cmp = h({
                type: n,
                selectors: [
                    ["", "mat-menu-item", ""]
                ],
                hostAttrs: [1, "mat-mdc-menu-item", "mat-focus-indicator"],
                hostVars: 8,
                hostBindings: function(t, i) {
                    t & 1 && v("click", function(d) {
                        return i._checkDisabled(d)
                    })("mouseenter", function() {
                        return i._handleMouseEnter()
                    }), t & 2 && (k("role", i.role)("tabindex", i._getTabIndex())("aria-disabled", i.disabled)("disabled", i.disabled || null), E("mat-mdc-menu-item-highlighted", i._highlighted)("mat-mdc-menu-item-submenu-trigger", i._triggersSubmenu))
                },
                inputs: {
                    role: "role",
                    disabled: [2, "disabled", "disabled", U],
                    disableRipple: [2, "disableRipple", "disableRipple", U]
                },
                exportAs: ["matMenuItem"],
                attrs: $a,
                ngContentSelectors: Wa,
                decls: 5,
                vars: 3,
                consts: [
                    [1, "mat-mdc-menu-item-text"],
                    ["matRipple", "", 1, "mat-mdc-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"],
                    ["viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-menu-submenu-icon"],
                    ["points", "0,0 5,5 0,10"]
                ],
                template: function(t, i) {
                    t & 1 && (ue(Qa), pe(0), l(1, "span", 0), pe(2, 1), p(), u(3, "div", 1), g(4, qa, 2, 0, ":svg:svg", 2)), t & 2 && (c(3), m("matRippleDisabled", i.disableRipple || i.disabled)("matRippleTrigger", i._getHostElement()), c(), b(i._triggersSubmenu ? 4 : -1))
                },
                dependencies: [Qe],
                encapsulation: 2,
                changeDetection: 0
            })
        }
        return n
    })();
var Wi = new se("MatMenuContent"),
    qi = (() => {
        class n {
            _template = s(we);
            _appRef = s(hn);
            _injector = s(Ie);
            _viewContainerRef = s(He);
            _document = s(Nt);
            _changeDetectorRef = s(be);
            _portal;
            _outlet;
            _attached = new ee;
            constructor() {}
            attach(e = {}) {
                this._portal || (this._portal = new $e(this._template, this._viewContainerRef)), this.detach(), this._outlet || (this._outlet = new ki(this._document.createElement("div"), null, this._appRef, this._injector));
                let t = this._template.elementRef.nativeElement;
                t.parentNode.insertBefore(this._outlet.outletElement, t), this._changeDetectorRef.markForCheck(), this._portal.attach(this._outlet, e), this._attached.next()
            }
            detach() {
                this._portal ? .isAttached && this._portal.detach()
            }
            ngOnDestroy() {
                this.detach(), this._outlet ? .dispose()
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275dir = te({
                type: n,
                selectors: [
                    ["ng-template", "matMenuContent", ""]
                ],
                features: [xe([{
                    provide: Wi,
                    useExisting: n
                }])]
            })
        }
        return n
    })(),
    Ka = new se("mat-menu-default-options", {
        providedIn: "root",
        factory: Za
    });

function Za() {
    return {
        overlapTrigger: !1,
        xPosition: "after",
        yPosition: "below",
        backdropClass: "cdk-overlay-transparent-backdrop"
    }
}
var en = "_mat-menu-enter",
    Tt = "_mat-menu-exit",
    Be = (() => {
        class n {
            _elementRef = s(le);
            _changeDetectorRef = s(be);
            _injector = s(Ie);
            _keyManager;
            _xPosition;
            _yPosition;
            _firstItemFocusRef;
            _exitFallbackTimeout;
            _animationsDisabled;
            _allItems;
            _directDescendantItems = new Ke;
            _classList = {};
            _panelAnimationState = "void";
            _animationDone = new ee;
            _isAnimating = !1;
            parentMenu;
            direction;
            overlayPanelClass;
            backdropClass;
            ariaLabel;
            ariaLabelledby;
            ariaDescribedby;
            get xPosition() {
                return this._xPosition
            }
            set xPosition(e) {
                this._xPosition = e, this.setPositionClasses()
            }
            get yPosition() {
                return this._yPosition
            }
            set yPosition(e) {
                this._yPosition = e, this.setPositionClasses()
            }
            templateRef;
            items;
            lazyContent;
            overlapTrigger;
            hasBackdrop;
            set panelClass(e) {
                let t = this._previousPanelClass,
                    i = Rt({}, this._classList);
                t && t.length && t.split(" ").forEach(a => {
                    i[a] = !1
                }), this._previousPanelClass = e, e && e.length && (e.split(" ").forEach(a => {
                    i[a] = !0
                }), this._elementRef.nativeElement.className = ""), this._classList = i
            }
            _previousPanelClass;
            get classList() {
                return this.panelClass
            }
            set classList(e) {
                this.panelClass = e
            }
            closed = new W;
            close = this.closed;
            panelId = s(_t).getId("mat-menu-panel-");
            constructor() {
                let e = s(Ka);
                this.overlayPanelClass = e.overlayPanelClass || "", this._xPosition = e.xPosition, this._yPosition = e.yPosition, this.backdropClass = e.backdropClass, this.overlapTrigger = e.overlapTrigger, this.hasBackdrop = e.hasBackdrop, this._animationsDisabled = s(Le, {
                    optional: !0
                }) === "NoopAnimations"
            }
            ngOnInit() {
                this.setPositionClasses()
            }
            ngAfterContentInit() {
                this._updateDirectDescendants(), this._keyManager = new yt(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(), this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")), this._directDescendantItems.changes.pipe(_e(this._directDescendantItems), Me(e => fe(...e.map(t => t._focused)))).subscribe(e => this._keyManager.updateActiveItem(e)), this._directDescendantItems.changes.subscribe(e => {
                    let t = this._keyManager;
                    if (this._panelAnimationState === "enter" && t.activeItem ? ._hasFocus()) {
                        let i = e.toArray(),
                            a = Math.max(0, Math.min(i.length - 1, t.activeItemIndex || 0));
                        i[a] && !i[a].disabled ? t.setActiveItem(a) : t.setNextItemActive()
                    }
                })
            }
            ngOnDestroy() {
                this._keyManager ? .destroy(), this._directDescendantItems.destroy(), this.closed.complete(), this._firstItemFocusRef ? .destroy(), clearTimeout(this._exitFallbackTimeout)
            }
            _hovered() {
                return this._directDescendantItems.changes.pipe(_e(this._directDescendantItems), Me(t => fe(...t.map(i => i._hovered))))
            }
            addItem(e) {}
            removeItem(e) {}
            _handleKeydown(e) {
                let t = e.keyCode,
                    i = this._keyManager;
                switch (t) {
                    case 27:
                        vt(e) || (e.preventDefault(), this.closed.emit("keydown"));
                        break;
                    case 37:
                        this.parentMenu && this.direction === "ltr" && this.closed.emit("keydown");
                        break;
                    case 39:
                        this.parentMenu && this.direction === "rtl" && this.closed.emit("keydown");
                        break;
                    default:
                        (t === 38 || t === 40) && i.setFocusOrigin("keyboard"), i.onKeydown(e);
                        return
                }
            }
            focusFirstItem(e = "program") {
                this._firstItemFocusRef ? .destroy(), this._firstItemFocusRef = Oe(() => {
                    let t = this._resolvePanel();
                    if (!t || !t.contains(document.activeElement)) {
                        let i = this._keyManager;
                        i.setFocusOrigin(e).setFirstItemActive(), !i.activeItem && t && t.focus()
                    }
                }, {
                    injector: this._injector
                })
            }
            resetActiveItem() {
                this._keyManager.setActiveItem(-1)
            }
            setElevation(e) {}
            setPositionClasses(e = this.xPosition, t = this.yPosition) {
                this._classList = on(Rt({}, this._classList), {
                    "mat-menu-before": e === "before",
                    "mat-menu-after": e === "after",
                    "mat-menu-above": t === "above",
                    "mat-menu-below": t === "below"
                }), this._changeDetectorRef.markForCheck()
            }
            _onAnimationDone(e) {
                let t = e === Tt;
                (t || e === en) && (t && (clearTimeout(this._exitFallbackTimeout), this._exitFallbackTimeout = void 0), this._animationDone.next(t ? "void" : "enter"), this._isAnimating = !1)
            }
            _onAnimationStart(e) {
                (e === en || e === Tt) && (this._isAnimating = !0)
            }
            _setIsOpen(e) {
                if (this._panelAnimationState = e ? "enter" : "void", e) {
                    if (this._keyManager.activeItemIndex === 0) {
                        let t = this._resolvePanel();
                        t && (t.scrollTop = 0)
                    }
                } else this._animationsDisabled || (this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(Tt), 200));
                this._animationsDisabled && setTimeout(() => {
                    this._onAnimationDone(e ? en : Tt)
                }), this._changeDetectorRef.markForCheck()
            }
            _updateDirectDescendants() {
                this._allItems.changes.pipe(_e(this._allItems)).subscribe(e => {
                    this._directDescendantItems.reset(e.filter(t => t._parentMenu === this)), this._directDescendantItems.notifyOnChanges()
                })
            }
            _resolvePanel() {
                let e = null;
                return this._directDescendantItems.length && (e = this._directDescendantItems.first._getHostElement().closest('[role="menu"]')), e
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275cmp = h({
                type: n,
                selectors: [
                    ["mat-menu"]
                ],
                contentQueries: function(t, i, a) {
                    if (t & 1 && (ge(a, Wi, 5), ge(a, qe, 5), ge(a, qe, 4)), t & 2) {
                        let d;
                        V(d = N()) && (i.lazyContent = d.first), V(d = N()) && (i._allItems = d), V(d = N()) && (i.items = d)
                    }
                },
                viewQuery: function(t, i) {
                    if (t & 1 && G(we, 5), t & 2) {
                        let a;
                        V(a = N()) && (i.templateRef = a.first)
                    }
                },
                hostVars: 3,
                hostBindings: function(t, i) {
                    t & 2 && k("aria-label", null)("aria-labelledby", null)("aria-describedby", null)
                },
                inputs: {
                    backdropClass: "backdropClass",
                    ariaLabel: [0, "aria-label", "ariaLabel"],
                    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
                    ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"],
                    xPosition: "xPosition",
                    yPosition: "yPosition",
                    overlapTrigger: [2, "overlapTrigger", "overlapTrigger", U],
                    hasBackdrop: [2, "hasBackdrop", "hasBackdrop", e => e == null ? null : U(e)],
                    panelClass: [0, "class", "panelClass"],
                    classList: "classList"
                },
                outputs: {
                    closed: "closed",
                    close: "close"
                },
                exportAs: ["matMenu"],
                features: [xe([{
                    provide: tn,
                    useExisting: n
                }])],
                ngContentSelectors: Ga,
                decls: 1,
                vars: 0,
                consts: [
                    ["tabindex", "-1", "role", "menu", 1, "mat-mdc-menu-panel", 3, "click", "animationstart", "animationend", "animationcancel", "id"],
                    [1, "mat-mdc-menu-content"]
                ],
                template: function(t, i) {
                    t & 1 && (ue(), g(0, Ya, 3, 12, "ng-template"))
                },
                styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}'],
                encapsulation: 2,
                changeDetection: 0
            })
        }
        return n
    })(),
    Gi = new se("mat-menu-scroll-strategy", {
        providedIn: "root",
        factory: () => {
            let n = s(Ct);
            return () => n.scrollStrategies.reposition()
        }
    });

function Xa(n) {
    return () => n.scrollStrategies.reposition()
}
var Ja = {
        provide: Gi,
        deps: [Ct],
        useFactory: Xa
    },
    eo = {
        passive: !0
    };
var We = new WeakMap,
    Yi = (() => {
        class n {
            _overlay = s(Ct);
            _element = s(le);
            _viewContainerRef = s(He);
            _menuItemInstance = s(qe, {
                optional: !0,
                self: !0
            });
            _dir = s(je, {
                optional: !0
            });
            _focusMonitor = s(bt);
            _ngZone = s(ye);
            _scrollStrategy = s(Gi);
            _changeDetectorRef = s(be);
            _cleanupTouchstart;
            _portal;
            _overlayRef = null;
            _menuOpen = !1;
            _closingActionsSubscription = re.EMPTY;
            _hoverSubscription = re.EMPTY;
            _menuCloseSubscription = re.EMPTY;
            _pendingRemoval;
            _parentMaterialMenu;
            _parentInnerPadding;
            _openedBy = void 0;
            get _deprecatedMatMenuTriggerFor() {
                return this.menu
            }
            set _deprecatedMatMenuTriggerFor(e) {
                this.menu = e
            }
            get menu() {
                return this._menu
            }
            set menu(e) {
                e !== this._menu && (this._menu = e, this._menuCloseSubscription.unsubscribe(), e && (this._parentMaterialMenu, this._menuCloseSubscription = e.close.subscribe(t => {
                    this._destroyMenu(t), (t === "click" || t === "tab") && this._parentMaterialMenu && this._parentMaterialMenu.closed.emit(t)
                })), this._menuItemInstance ? ._setTriggersSubmenu(this.triggersSubmenu()))
            }
            _menu;
            menuData;
            restoreFocus = !0;
            menuOpened = new W;
            onMenuOpen = this.menuOpened;
            menuClosed = new W;
            onMenuClose = this.menuClosed;
            constructor() {
                let e = s(tn, {
                        optional: !0
                    }),
                    t = s(ze);
                this._parentMaterialMenu = e instanceof Be ? e : void 0, this._cleanupTouchstart = Ue(t, this._element.nativeElement, "touchstart", i => {
                    _i(i) || (this._openedBy = "touch")
                }, eo)
            }
            ngAfterContentInit() {
                this._handleHover()
            }
            ngOnDestroy() {
                this.menu && this._ownsMenu(this.menu) && We.delete(this.menu), this._cleanupTouchstart(), this._pendingRemoval ? .unsubscribe(), this._menuCloseSubscription.unsubscribe(), this._closingActionsSubscription.unsubscribe(), this._hoverSubscription.unsubscribe(), this._overlayRef && (this._overlayRef.dispose(), this._overlayRef = null)
            }
            get menuOpen() {
                return this._menuOpen
            }
            get dir() {
                return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr"
            }
            triggersSubmenu() {
                return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu)
            }
            toggleMenu() {
                return this._menuOpen ? this.closeMenu() : this.openMenu()
            }
            openMenu() {
                let e = this.menu;
                if (this._menuOpen || !e) return;
                this._pendingRemoval ? .unsubscribe();
                let t = We.get(e);
                We.set(e, this), t && t !== this && t.closeMenu();
                let i = this._createOverlay(e),
                    a = i.getConfig(),
                    d = a.positionStrategy;
                this._setPosition(e, d), a.hasBackdrop = e.hasBackdrop == null ? !this.triggersSubmenu() : e.hasBackdrop, i.hasAttached() || (i.attach(this._getPortal(e)), e.lazyContent ? .attach(this.menuData)), this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu()), e.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0, e.direction = this.dir, e.focusFirstItem(this._openedBy || "program"), this._setIsMenuOpen(!0), e instanceof Be && (e._setIsOpen(!0), e._directDescendantItems.changes.pipe(y(e.close)).subscribe(() => {
                    d.withLockedPosition(!1).reapplyLastPosition(), d.withLockedPosition(!0)
                }))
            }
            closeMenu() {
                this.menu ? .close.emit()
            }
            focus(e, t) {
                this._focusMonitor && e ? this._focusMonitor.focusVia(this._element, e, t) : this._element.nativeElement.focus(t)
            }
            updatePosition() {
                this._overlayRef ? .updatePosition()
            }
            _destroyMenu(e) {
                let t = this._overlayRef,
                    i = this._menu;
                !t || !this.menuOpen || (this._closingActionsSubscription.unsubscribe(), this._pendingRemoval ? .unsubscribe(), i instanceof Be && this._ownsMenu(i) ? (this._pendingRemoval = i._animationDone.pipe(ln(1)).subscribe(() => {
                    t.detach(), i.lazyContent ? .detach()
                }), i._setIsOpen(!1)) : (t.detach(), i ? .lazyContent ? .detach()), i && this._ownsMenu(i) && We.delete(i), this.restoreFocus && (e === "keydown" || !this._openedBy || !this.triggersSubmenu()) && this.focus(this._openedBy), this._openedBy = void 0, this._setIsMenuOpen(!1))
            }
            _setIsMenuOpen(e) {
                e !== this._menuOpen && (this._menuOpen = e, this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(), this.triggersSubmenu() && this._menuItemInstance._setHighlighted(e), this._changeDetectorRef.markForCheck())
            }
            _createOverlay(e) {
                if (!this._overlayRef) {
                    let t = this._getOverlayConfig(e);
                    this._subscribeToPositions(e, t.positionStrategy), this._overlayRef = this._overlay.create(t), this._overlayRef.keydownEvents().subscribe(i => {
                        this.menu instanceof Be && this.menu._handleKeydown(i)
                    })
                }
                return this._overlayRef
            }
            _getOverlayConfig(e) {
                return new Ti({
                    positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),
                    backdropClass: e.backdropClass || "cdk-overlay-transparent-backdrop",
                    panelClass: e.overlayPanelClass,
                    scrollStrategy: this._scrollStrategy(),
                    direction: this._dir || "ltr"
                })
            }
            _subscribeToPositions(e, t) {
                e.setPositionClasses && t.positionChanges.subscribe(i => {
                    this._ngZone.run(() => {
                        let a = i.connectionPair.overlayX === "start" ? "after" : "before",
                            d = i.connectionPair.overlayY === "top" ? "below" : "above";
                        e.setPositionClasses(a, d)
                    })
                })
            }
            _setPosition(e, t) {
                let [i, a] = e.xPosition === "before" ? ["end", "start"] : ["start", "end"], [d, S] = e.yPosition === "above" ? ["bottom", "top"] : ["top", "bottom"], [L, X] = [d, S], [J, Et] = [i, a], Ae = 0;
                if (this.triggersSubmenu()) {
                    if (Et = i = e.xPosition === "before" ? "start" : "end", a = J = i === "end" ? "start" : "end", this._parentMaterialMenu) {
                        if (this._parentInnerPadding == null) {
                            let an = this._parentMaterialMenu.items.first;
                            this._parentInnerPadding = an ? an._getHostElement().offsetTop : 0
                        }
                        Ae = d === "bottom" ? this._parentInnerPadding : -this._parentInnerPadding
                    }
                } else e.overlapTrigger || (L = d === "top" ? "bottom" : "top", X = S === "top" ? "bottom" : "top");
                t.withPositions([{
                    originX: i,
                    originY: L,
                    overlayX: J,
                    overlayY: d,
                    offsetY: Ae
                }, {
                    originX: a,
                    originY: L,
                    overlayX: Et,
                    overlayY: d,
                    offsetY: Ae
                }, {
                    originX: i,
                    originY: X,
                    overlayX: J,
                    overlayY: S,
                    offsetY: -Ae
                }, {
                    originX: a,
                    originY: X,
                    overlayX: Et,
                    overlayY: S,
                    offsetY: -Ae
                }])
            }
            _menuClosingActions() {
                let e = this._overlayRef.backdropClick(),
                    t = this._overlayRef.detachments(),
                    i = this._parentMaterialMenu ? this._parentMaterialMenu.closed : Ve(),
                    a = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(ce(d => this._menuOpen && d !== this._menuItemInstance)) : Ve();
                return fe(e, i, a, t)
            }
            _handleMousedown(e) {
                fi(e) || (this._openedBy = e.button === 0 ? "mouse" : void 0, this.triggersSubmenu() && e.preventDefault())
            }
            _handleKeydown(e) {
                let t = e.keyCode;
                (t === 13 || t === 32) && (this._openedBy = "keyboard"), this.triggersSubmenu() && (t === 39 && this.dir === "ltr" || t === 37 && this.dir === "rtl") && (this._openedBy = "keyboard", this.openMenu())
            }
            _handleClick(e) {
                this.triggersSubmenu() ? (e.stopPropagation(), this.openMenu()) : this.toggleMenu()
            }
            _handleHover() {
                this.triggersSubmenu() && this._parentMaterialMenu && (this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe(e => {
                    e === this._menuItemInstance && !e.disabled && (this._openedBy = "mouse", this.openMenu())
                }))
            }
            _getPortal(e) {
                return (!this._portal || this._portal.templateRef !== e.templateRef) && (this._portal = new $e(e.templateRef, this._viewContainerRef)), this._portal
            }
            _ownsMenu(e) {
                return We.get(e) === this
            }
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275dir = te({
                type: n,
                selectors: [
                    ["", "mat-menu-trigger-for", ""],
                    ["", "matMenuTriggerFor", ""]
                ],
                hostAttrs: [1, "mat-mdc-menu-trigger"],
                hostVars: 3,
                hostBindings: function(t, i) {
                    t & 1 && v("click", function(d) {
                        return i._handleClick(d)
                    })("mousedown", function(d) {
                        return i._handleMousedown(d)
                    })("keydown", function(d) {
                        return i._handleKeydown(d)
                    }), t & 2 && k("aria-haspopup", i.menu ? "menu" : null)("aria-expanded", i.menuOpen)("aria-controls", i.menuOpen ? i.menu.panelId : null)
                },
                inputs: {
                    _deprecatedMatMenuTriggerFor: [0, "mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"],
                    menu: [0, "matMenuTriggerFor", "menu"],
                    menuData: [0, "matMenuTriggerData", "menuData"],
                    restoreFocus: [0, "matMenuTriggerRestoreFocus", "restoreFocus"]
                },
                outputs: {
                    menuOpened: "menuOpened",
                    onMenuOpen: "onMenuOpen",
                    menuClosed: "menuClosed",
                    onMenuClose: "onMenuClose"
                },
                exportAs: ["matMenuTrigger"]
            })
        }
        return n
    })(),
    Ki = (() => {
        class n {
            static\ u0275fac = function(t) {
                return new(t || n)
            };
            static\ u0275mod = Xe({
                type: n
            });
            static\ u0275inj = Ye({
                providers: [Ja],
                imports: [Di, Re, wi, xi, Re]
            })
        }
        return n
    })(),
    Zi = {
        transformMenu: {
            type: 7,
            name: "transformMenu",
            definitions: [{
                type: 0,
                name: "void",
                styles: {
                    type: 6,
                    styles: {
                        opacity: 0,
                        transform: "scale(0.8)"
                    },
                    offset: null
                }
            }, {
                type: 1,
                expr: "void => enter",
                animation: {
                    type: 4,
                    styles: {
                        type: 6,
                        styles: {
                            opacity: 1,
                            transform: "scale(1)"
                        },
                        offset: null
                    },
                    timings: "120ms cubic-bezier(0, 0, 0.2, 1)"
                },
                options: null
            }, {
                type: 1,
                expr: "* => void",
                animation: {
                    type: 4,
                    styles: {
                        type: 6,
                        styles: {
                            opacity: 0
                        },
                        offset: null
                    },
                    timings: "100ms 25ms linear"
                },
                options: null
            }],
            options: {}
        },
        fadeInItems: {
            type: 7,
            name: "fadeInItems",
            definitions: [{
                type: 0,
                name: "showing",
                styles: {
                    type: 6,
                    styles: {
                        opacity: 1
                    },
                    offset: null
                }
            }, {
                type: 1,
                expr: "void => *",
                animation: [{
                    type: 6,
                    styles: {
                        opacity: 0
                    },
                    offset: null
                }, {
                    type: 4,
                    styles: null,
                    timings: "400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)"
                }],
                options: null
            }],
            options: {}
        }
    },
    tc = Zi.fadeInItems,
    nc = Zi.transformMenu;
var Xi = (() => {
    class n {
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-flag-icon"]
                ],
                inputs: {
                    country: "country",
                    squared: "squared"
                },
                decls: 1,
                vars: 4,
                template: function(t, i) {
                    t & 1 && u(0, "span"), t & 2 && (Ce("fi fi-" + i.country), E("fis", i.squared))
                },
                styles: [`@charset "UTF-8";span[_ngcontent-%COMP%]{background-size:cover;border-radius:50%;width:1em;margin-inline-end:.5em}.fib[_ngcontent-%COMP%], .fi[_ngcontent-%COMP%]{background-size:contain;background-position:50%;background-repeat:no-repeat}.fi[_ngcontent-%COMP%]{position:relative;display:inline-block;width:1.333333em;line-height:1em}.fi[_ngcontent-%COMP%]:before{content:"\\a0"}.fi.fis[_ngcontent-%COMP%]{width:1em}.fi-sy[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/sy.svg)}.fi-sy.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/sy.svg)}.fi-by[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/by.svg)}.fi-by.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/by.svg)}.fi-bg[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/bg.svg)}.fi-bg.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/bg.svg)}.fi-cn[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/cn.svg)}.fi-cn.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/cn.svg)}.fi-hr[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/hr.svg)}.fi-hr.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/hr.svg)}.fi-ch[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ch.svg)}.fi-ch.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ch.svg)}.fi-cz[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/cz.svg)}.fi-cz.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/cz.svg)}.fi-dk[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/dk.svg)}.fi-dk.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/dk.svg)}.fi-in[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/in.svg)}.fi-in.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/in.svg)}.fi-nz[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/nz.svg)}.fi-nz.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/nz.svg)}.fi-gb[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/gb.svg)}.fi-gb.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/gb.svg)}.fi-jo[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/jo.svg)}.fi-jo.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/jo.svg)}.fi-us[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/us.svg)}.fi-us.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/us.svg)}.fi-ee[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ee.svg)}.fi-ee.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ee.svg)}.fi-fi[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/fi.svg)}.fi-fi.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/fi.svg)}.fi-fr[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/fr.svg)}.fi-fr.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/fr.svg)}.fi-at[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/at.svg)}.fi-at.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/at.svg)}.fi-de[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/de.svg)}.fi-de.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/de.svg)}.fi-cy[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/cy.svg)}.fi-cy.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/cy.svg)}.fi-gr[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/gr.svg)}.fi-gr.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/gr.svg)}.fi-il[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/il.svg)}.fi-il.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/il.svg)}.fi-is[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/is.svg)}.fi-is.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/is.svg)}.fi-it[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/it.svg)}.fi-it.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/it.svg)}.fi-jp[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/jp.svg)}.fi-jp.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/jp.svg)}.fi-lv[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/lv.svg)}.fi-lv.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/lv.svg)}.fi-lt[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/lt.svg)}.fi-lt.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/lt.svg)}.fi-ir[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ir.svg)}.fi-ir.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ir.svg)}.fi-pl[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/pl.svg)}.fi-pl.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/pl.svg)}.fi-br[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/br.svg)}.fi-br.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/br.svg)}.fi-pt[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/pt.svg)}.fi-pt.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/pt.svg)}.fi-ro[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ro.svg)}.fi-ro.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ro.svg)}.fi-ru[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ru.svg)}.fi-ru.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ru.svg)}.fi-sk[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/sk.svg)}.fi-sk.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/sk.svg)}.fi-ar[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ar.svg)}.fi-ar.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ar.svg)}.fi-cl[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/cl.svg)}.fi-cl.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/cl.svg)}.fi-cu[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/cu.svg)}.fi-cu.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/cu.svg)}.fi-mx[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/mx.svg)}.fi-mx.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/mx.svg)}.fi-es[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/es.svg)}.fi-es.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/es.svg)}.fi-se[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/se.svg)}.fi-se.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/se.svg)}.fi-tr[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/tr.svg)}.fi-tr.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/tr.svg)}.fi-ua[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ua.svg)}.fi-ua.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ua.svg)}.fi-pk[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/pk.svg)}.fi-pk.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/pk.svg)}.fi-ils[_ngcontent-%COMP%]{background-image:url(/assets/flags/4x3/ils.svg)}.fi-ils.fis[_ngcontent-%COMP%]{background-image:url(/assets/flags/1x1/ils.svg)}
/*# sourceMappingURL=flag-icon.component-GRYC6SVM.css.map */`]
            })
        }
    }
    return n
})();
var ea = n => ({
    lang: n
});

function no(n, o) {
    if (n & 1 && I(0), n & 2) {
        let e = r(3).$implicit,
            t = r();
        H(" ", e("detected", Vt(1, ea, t.langNames[t.detectedLanguage])), " ")
    }
}

function io(n, o) {
    n & 1 && (l(0, "mat-tab"), g(1, no, 1, 3, "ng-template", 9), p())
}

function ao(n, o) {
    if (n & 1 && u(0, "mat-tab", 8), n & 2) {
        let e = r(2).$implicit;
        m("label", e("detect"))
    }
}

function oo(n, o) {
    if (n & 1 && g(0, io, 2, 0, "mat-tab")(1, ao, 1, 1, "mat-tab", 8), n & 2) {
        let e = r(2);
        b(e.detectedLanguage && !e.language ? 0 : 1)
    }
}

function ro(n, o) {
    if (n & 1 && u(0, "app-flag-icon", 11), n & 2) {
        let e = r(2).$implicit,
            t = r(2);
        m("country", t.langCountries[e])("squared", !0)
    }
}

function so(n, o) {
    if (n & 1 && (g(0, ro, 1, 2, "app-flag-icon", 11), I(1)), n & 2) {
        let e = r().$implicit,
            t = r(2);
        b(t.flags ? 0 : -1), c(), H(" ", t.langNames[e], " ")
    }
}

function co(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "mat-tab", 10), v("select", function() {
            let i = f(e).$implicit,
                a = r(2);
            return _(a.selectLanguage(i))
        }), g(1, so, 2, 2, "ng-template", 9), p()
    }
}

function lo(n, o) {
    if (n & 1 && u(0, "app-flag-icon", 11), n & 2) {
        let e = r(3);
        m("country", e.langCountries[e.detectedLanguage])("squared", !0)
    }
}

function po(n, o) {
    if (n & 1 && (l(0, "ion-button", 3), g(1, lo, 1, 2, "app-flag-icon", 11), l(2, "span", 12), I(3), p()()), n & 2) {
        let e = r().$implicit,
            t = me(10),
            i = r();
        m("matMenuTriggerFor", t), c(), b(i.flags ? 1 : -1), c(2), j(e("detected", Vt(3, ea, i.langNames[i.detectedLanguage])))
    }
}

function mo(n, o) {
    if (n & 1 && u(0, "app-flag-icon", 11), n & 2) {
        let e = r(4);
        m("country", e.langCountries[e.language])("squared", !0)
    }
}

function uo(n, o) {
    if (n & 1 && (g(0, mo, 1, 2, "app-flag-icon", 11), l(1, "span", 12), I(2), p()), n & 2) {
        let e = r(3);
        b(e.flags ? 0 : -1), c(2), j(e.langNames[e.language])
    }
}

function go(n, o) {
    if (n & 1 && I(0), n & 2) {
        let e = r(2).$implicit;
        H(" ", e("detect"), " ")
    }
}

function bo(n, o) {
    if (n & 1 && (l(0, "ion-button", 3), g(1, uo, 3, 2)(2, go, 1, 1), p()), n & 2) {
        r();
        let e = me(10),
            t = r();
        m("matMenuTriggerFor", e), c(), b(t.language ? 1 : 2)
    }
}

function ho(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "button", 14), v("click", function() {
            f(e);
            let i = r(3);
            return _(i.selectLanguage(null))
        }), I(1), p()
    }
    if (n & 2) {
        let e = r(2).$implicit;
        c(), H(" ", e("detect"), " ")
    }
}

function fo(n, o) {
    if (n & 1 && u(0, "app-flag-icon", 11), n & 2) {
        let e = r().$implicit,
            t = r(3);
        m("country", t.langCountries[e])("squared", !0)
    }
}

function _o(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "button", 14), v("click", function() {
            let i = f(e).$implicit,
                a = r(3);
            return _(a.selectLanguage(i))
        }), g(1, fo, 1, 2, "app-flag-icon", 11), I(2), p()
    }
    if (n & 2) {
        let e = o.$implicit,
            t = r(3);
        c(), b(t.flags ? 1 : -1), c(), H(" ", t.langNames[e], " ")
    }
}

function vo(n, o) {
    if (n & 1 && (g(0, ho, 2, 1, "button", 13), ne(1, _o, 3, 2, "button", 13, de)), n & 2) {
        let e = r(2);
        b(e.hasLanguageDetection ? 0 : -1), c(), ie(e.languages)
    }
}

function yo(n, o) {
    if (n & 1) {
        let e = w();
        ae(0), l(1, "mat-tab-group", 2), v("selectedIndexChange", function(i) {
            f(e);
            let a = r();
            return _(a.selectLanguageIndex(i))
        }), Cn("selectedIndexChange", function(i) {
            f(e);
            let a = r();
            return yn(a.selectedIndex, i) || (a.selectedIndex = i), _(i)
        }), g(2, oo, 2, 1), ne(3, co, 2, 0, "mat-tab", null, de), p(), g(5, po, 4, 5, "ion-button", 3)(6, bo, 3, 2, "ion-button", 3), l(7, "ion-button", 4), u(8, "ion-icon", 5), p(), l(9, "mat-menu", 6, 0), g(11, vo, 3, 1, "ng-template", 7), p(), oe()
    }
    if (n & 2) {
        let e = o.$implicit,
            t = me(10),
            i = r();
        c(), vn("selectedIndex", i.selectedIndex), m("disablePagination", !0), c(), b(i.hasLanguageDetection ? 2 : -1), c(), ie(i.topLanguages), c(2), b(i.hasLanguageDetection && i.detectedLanguage && !i.language ? 5 : 6), c(2), m("matMenuTriggerFor", t), k("aria-label", e("more"))
    }
}
var Ji = {
        languages: "language",
        countries: "region"
    },
    ta = (() => {
        class n extends $ {
            constructor() {
                super(), this.store = s(D), this.transloco = s(pt), this.flags = !1, this.hasLanguageDetection = !1, this.languageChange = Te(), this.selectedIndex = 0, this.langNames = {}, this.langCountries = {}, A({
                    chevronDown: Jn
                })
            }
            ngOnInit() {
                this.language || this.selectLanguage(this.languages[0]), this.setLangNames(this.transloco.getActiveLang()), this.transloco.langChanges$.pipe(Me(() => this.transloco.events$), ce(e => e.type === "translationLoadSuccess" && e.payload.scope === this.translationKey), T(() => this.setLangNames(this.transloco.getActiveLang())), y(this.ngUnsubscribe)).subscribe(), this.setLangCountries(), this.store.select(e => e.translate.detectedLanguage).pipe(T(e => this.detectedLanguage = e), y(this.ngUnsubscribe)).subscribe()
            }
            ngOnChanges(e) {
                e.language && this.selectLanguage(e.language.currentValue)
            }
            langName(e) {
                if (this.displayNames && e.length === 2) {
                    let t = this.displayNames.of(e.toUpperCase());
                    if (t && t !== e) return t
                }
                return this.transloco.translate(`${this.translationKey}.${e}`)
            }
            setLangNames(e) {
                this.translationKey in Ji && (this.displayNames = new Intl.DisplayNames([e], {
                    type: Ji[this.translationKey]
                }), this.displayNames.resolvedOptions().locale !== e && (console.error("Failed to set language display names for locale", e), delete this.displayNames));
                for (let t of this.languages) this.langNames[t] = this.langName(t)
            }
            setLangCountries() {
                let e = this.translationKey === "languages" ? "language" : "signed";
                for (let t of this.languages) {
                    let i = Ri.find(a => a[e] === t);
                    this.langCountries[t] = i ? .country ? ? "xx"
                }
                this.langCountries.ils = "ils"
            }
            selectLanguage(e) {
                this.topLanguages || (this.topLanguages = this.languages.slice(0, 3)), e !== this.language && (this.language = e, this.languageChange.emit(this.language)), e && !this.topLanguages.includes(e) && (this.topLanguages.unshift(e), this.topLanguages.pop());
                let t = this.topLanguages.indexOf(this.language);
                this.selectedIndex = t + Number(this.hasLanguageDetection)
            }
            selectLanguageIndex(e) {
                e === 0 && this.hasLanguageDetection ? this.selectLanguage(null) : this.selectLanguage(this.topLanguages[e - Number(this.hasLanguageDetection)])
            }
            static {
                this.\u0275fac = function(t) {
                    return new(t || n)
                }
            }
            static {
                this.\u0275cmp = h({
                    type: n,
                    selectors: [
                        ["app-language-selector"]
                    ],
                    inputs: {
                        flags: "flags",
                        hasLanguageDetection: "hasLanguageDetection",
                        languages: "languages",
                        translationKey: "translationKey",
                        language: "language"
                    },
                    outputs: {
                        languageChange: "languageChange"
                    },
                    features: [P, ve],
                    decls: 1,
                    vars: 1,
                    consts: [
                        ["signedLanguagesMenu", ""],
                        [4, "transloco", "translocoRead"],
                        [3, "selectedIndexChange", "selectedIndex", "disablePagination"],
                        ["color", "primary", "expand", "full", "fill", "clear", 1, "menu-language-button", 3, "matMenuTriggerFor"],
                        ["fill", "clear", "color", "medium", 1, "menu-icon-button", 3, "matMenuTriggerFor"],
                        ["name", "chevron-down", "slot", "icon-only"],
                        [1, "language-selector-menu"],
                        ["matMenuContent", ""],
                        [3, "label"],
                        ["mat-tab-label", ""],
                        [3, "select"],
                        [3, "country", "squared"],
                        [1, "wrap-text"],
                        ["mat-menu-item", ""],
                        ["mat-menu-item", "", 3, "click"]
                    ],
                    template: function(t, i) {
                        t & 1 && g(0, yo, 12, 6, "ng-container", 1), t & 2 && m("translocoRead", "translate.language-selector")
                    },
                    dependencies: [Xi, Ki, Be, qe, qi, Yi, z, K, ji, Xt, Jt, Ui, B, F],
                    styles: [`[_nghost-%COMP%]{display:flex;overflow:hidden}mat-tab-group[_ngcontent-%COMP%]{display:inline-block}ion-button.menu-icon-button[_ngcontent-%COMP%]{height:100%;margin:0}ion-button.menu-icon-button[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{transition:transform .2s cubic-bezier(.4,0,.2,1)}ion-button.menu-icon-button[aria-expanded=true][_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{transform:rotate(-180deg)}ion-button.menu-language-button[_ngcontent-%COMP%]{display:none;width:100%;height:100%;margin:0}@media screen and (max-width: 959px){ion-button.menu-icon-button[_ngcontent-%COMP%], mat-tab-group[_ngcontent-%COMP%]{display:none}ion-button.menu-language-button[_ngcontent-%COMP%]{display:block}}[_nghost-%COMP%]     div[role=tab]{font-weight:400;padding:0 16px}  .language-selector-menu{max-height:calc(100vh - 180px)!important}.wrap-text[_ngcontent-%COMP%]{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
/*# sourceMappingURL=language-selector.component-UXGWMU4W.css.map */`]
                })
            }
        }
        return n
    })();
var wt = (() => {
    class n extends $ {
        constructor() {
            super(), this.store = s(D), this.translation = s(ut), this.spokenToSigned$ = this.store.select(e => e.translate.spokenToSigned), this.spokenLanguage$ = this.store.select(e => e.translate.spokenLanguage), this.signedLanguage$ = this.store.select(e => e.translate.signedLanguage), this.detectedLanguage$ = this.store.select(e => e.translate.detectedLanguage), A({
                swapHorizontal: mi
            })
        }
        ngOnInit() {
            this.spokenToSigned$.pipe(T(e => {
                this.spokenToSigned = e
            }), y(this.ngUnsubscribe)).subscribe()
        }
        setSignedLanguage(e) {
            this.store.dispatch(new Vn(e))
        }
        setSpokenLanguage(e) {
            this.store.dispatch(new mt(e))
        }
        swapLanguages() {
            this.store.dispatch(Fn)
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-language-selectors"]
                ],
                hostVars: 2,
                hostBindings: function(t, i) {
                    t & 2 && E("spoken-to-signed", i.spokenToSigned)
                },
                features: [P],
                decls: 10,
                vars: 22,
                consts: [
                    ["translationKey", "signedLanguagesShort", 3, "languageChange", "flags", "hasLanguageDetection", "languages", "language"],
                    ["id", "swap-languages", "fill", "clear", "expand", "full", "color", "dark", 3, "click", "disabled", "matTooltip"],
                    ["name", "swap-horizontal"],
                    ["translationKey", "languages", 3, "languageChange", "hasLanguageDetection", "languages", "language"]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "app-language-selector", 0), C(1, "async"), v("languageChange", function(d) {
                        return i.setSignedLanguage(d)
                    }), p(), l(2, "ion-button", 1), C(3, "async"), C(4, "async"), C(5, "transloco"), C(6, "transloco"), v("click", function() {
                        return i.swapLanguages()
                    }), u(7, "ion-icon", 2), p(), l(8, "app-language-selector", 3), C(9, "async"), v("languageChange", function(d) {
                        return i.setSpokenLanguage(d)
                    }), p()), t & 2 && (m("flags", !0)("hasLanguageDetection", !1)("languages", i.translation.signedLanguages)("language", x(1, 10, i.signedLanguage$)), c(2), m("disabled", x(3, 12, i.spokenLanguage$) === null && x(4, 14, i.detectedLanguage$) === null)("matTooltip", x(5, 16, "translate.swapLanguages")), k("aria-label", x(6, 18, "translate.swapLanguages")), c(6), m("hasLanguageDetection", i.spokenToSigned)("languages", i.translation.spokenLanguages)("language", x(9, 20, i.spokenLanguage$)))
                },
                dependencies: [ta, Y, z, Q, Z, B, F],
                styles: [`[_nghost-%COMP%]{display:flex}.spoken-to-signed[_nghost-%COMP%]{flex-direction:row-reverse}app-language-selector[_ngcontent-%COMP%]{width:calc(50% - 24px)}#swap-languages[_ngcontent-%COMP%]{height:48px;margin:0}#swap-languages[disabled][_ngcontent-%COMP%]{opacity:.5}
/*# sourceMappingURL=language-selectors.component-ZM3ESPAZ.css.map */`]
            })
        }
    }
    return n
})();
var na = (() => {
    class n {
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-send-feedback"]
                ],
                decls: 3,
                vars: 3,
                consts: [
                    ["href", "https://github.com/sign/translate/issues", "target", "_blank"]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "a", 0), I(1), C(2, "transloco"), p()), t & 2 && (c(), H(" ", x(2, 1, "settings.support.feedback.send"), `
`))
                },
                dependencies: [Z],
                styles: [`a[_ngcontent-%COMP%]{float:right;color:var(--ion-text-color);font-size:12px;font-style:italic;font-weight:400;margin:8px 0;text-decoration:none}@media screen and (max-width: 1279px){a[_ngcontent-%COMP%]{padding:0 12px}}  html[dir=rtl] a{float:left}
/*# sourceMappingURL=send-feedback.component-74456UDJ.css.map */`]
            })
        }
    }
    return n
})();

function Co(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-button", 3), v("click", function() {
            f(e);
            let i = r(2);
            return _(i.isRecording ? i.stop() : i.start())
        }), u(1, "ion-icon", 4), p()
    }
    if (n & 2) {
        let e = r().$implicit,
            t = r();
        m("matTooltip", e(t.isRecording ? "stop" : "start"))("matTooltipPosition", t.matTooltipPosition), k("aria-label", e(t.isRecording ? "stop" : "start")), c(), m("name", t.isRecording ? "stop-circle-outline" : "mic-outline")
    }
}

function xo(n, o) {
    if (n & 1 && (l(0, "ion-button", 2), u(1, "ion-icon", 5), p()), n & 2) {
        let e = r().$implicit,
            t = r();
        m("matTooltip", e(t.supportError))("matTooltipPosition", t.matTooltipPosition), k("aria-label", e(t.supportError))
    }
}

function ko(n, o) {
    if (n & 1 && (ae(0), g(1, Co, 2, 4, "ion-button", 1)(2, xo, 2, 3, "ion-button", 2), oe()), n & 2) {
        let e = r();
        c(), b(e.supportError ? 2 : 1)
    }
}
var ia = (() => {
    class n extends $ {
        constructor() {
            super(), this.lang = "en", this.changeText = Te(), this.matTooltipPosition = "above", this.SpeechRecognition = globalThis.SpeechRecognition || globalThis.webkitSpeechRecognition, this.supportError = null, this.isRecording = !1, A({
                stopCircleOutline: gt,
                micOutline: ci
            })
        }
        ngOnInit() {
            if (!this.SpeechRecognition) {
                this.supportError = "browser-not-supported";
                return
            }
            this.speechRecognition = new this.SpeechRecognition, this.speechRecognition.interimResults = !0, this.speechRecognition.continuous = !1, this.speechRecognition.lang = this.lang, R(this.speechRecognition, "result").subscribe(e => {
                let t = e.results[0][0].transcript;
                this.changeText.emit(t)
            }), R(this.speechRecognition, "error").subscribe(e => {
                console.error("error", e.error), ["not-allowed", "language-not-supported", "service-not-allowed"].includes(e.error) ? this.supportError = e.error : this.supportError = null, e.error === "not-allowed" && this.requestPermission()
            }), R(this.speechRecognition, "start").subscribe(() => {
                console.error("start"), this.changeText.emit(""), this.isRecording = !0
            }), R(this.speechRecognition, "end").subscribe(() => {
                this.isRecording = !1, this.speechRecognition.stop()
            }), R(this.speechRecognition, "speechend").subscribe(this.stop.bind(this))
        }
        ngOnChanges(e) {
            e.lang && this.speechRecognition && (this.speechRecognition.lang = this.lang)
        }
        requestPermission() {
            navigator.mediaDevices.getUserMedia({
                video: !1,
                audio: !0
            }).then(e => {
                e.getTracks().forEach(t => t.stop()), this.supportError = null
            })
        }
        start() {
            this.speechRecognition.start()
        }
        stop() {
            this.speechRecognition.stop()
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-speech-to-text"]
                ],
                inputs: {
                    lang: "lang",
                    matTooltipPosition: "matTooltipPosition"
                },
                outputs: {
                    changeText: "changeText"
                },
                features: [P, ve],
                decls: 1,
                vars: 1,
                consts: [
                    [4, "transloco", "translocoRead"],
                    ["fill", "clear", "shape", "round", "color", "dark", 1, "circle-icon", 3, "matTooltip", "matTooltipPosition"],
                    ["fill", "clear", "shape", "round", "color", "medium", 1, "circle-icon", 3, "matTooltip", "matTooltipPosition"],
                    ["fill", "clear", "shape", "round", "color", "dark", 1, "circle-icon", 3, "click", "matTooltip", "matTooltipPosition"],
                    ["slot", "icon-only", "color", "primary", 3, "name"],
                    ["name", "mic-off-outline", "slot", "icon-only"]
                ],
                template: function(t, i) {
                    t & 1 && g(0, ko, 3, 1, "ng-container", 0), t & 2 && m("translocoRead", "speech-to-text")
                },
                dependencies: [B, F, z, Q, K],
                encapsulation: 2
            })
        }
    }
    return n
})();

function Mo(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-button", 3), v("click", function() {
            f(e);
            let i = r(3);
            return _(i.isSpeaking ? i.cancel() : i.play())
        }), u(1, "ion-icon", 4), p()
    }
    if (n & 2) {
        let e = r(2).$implicit,
            t = r();
        m("matTooltip", e(t.isSpeaking ? "cancel" : "play")), k("aria-label", e(t.isSpeaking ? "cancel" : "play")), c(), m("name", t.isSpeaking ? "stop-circle-outline" : "volume-medium-outline")
    }
}

function To(n, o) {
    if (n & 1 && (l(0, "ion-button", 2), u(1, "ion-icon", 5), p()), n & 2) {
        let e = r(2).$implicit;
        m("matTooltip", e("unavailable")), k("aria-label", e("unavailable"))
    }
}

function wo(n, o) {
    if (n & 1 && g(0, Mo, 2, 3, "ion-button", 1)(1, To, 2, 2, "ion-button", 2), n & 2) {
        let e = r(2);
        b(e.isSupported ? 0 : 1)
    }
}

function So(n, o) {
    if (n & 1 && (ae(0), g(1, wo, 2, 1), oe()), n & 2) {
        let e = r();
        c(), b(e.text.trim() ? 1 : -1)
    }
}
var St = (() => {
    class n {
        constructor() {
            this.lang = "en", this.text = "", this.voices = [], this.isSupported = !1, this.isSpeaking = !1, this.speech = "SpeechSynthesisUtterance" in globalThis ? new SpeechSynthesisUtterance : null, this.listeners = {}, A({
                stopCircleOutline: gt,
                volumeMediumOutline: gi,
                volumeMuteOutline: bi
            })
        }
        ngOnInit() {
            if (!this.speech) return;
            let e = () => {
                this.voices = globalThis.speechSynthesis.getVoices(), this.setVoice()
            };
            if (e(), "addEventListener" in globalThis.speechSynthesis) {
                this.listeners.voiceschanged = e;
                for (let [t, i] of Object.entries(this.listeners)) globalThis.speechSynthesis.addEventListener(t, i)
            }
            this.speech.addEventListener("start", () => this.isSpeaking = !0), this.speech.addEventListener("end", () => this.isSpeaking = !1)
        }
        ngOnDestroy() {
            if (this.speech)
                for (let [e, t] of Object.entries(this.listeners)) globalThis.speechSynthesis.removeEventListener(e, t)
        }
        ngOnChanges(e) {
            this.speech && e.lang && (this.speech.lang = this.lang, this.setVoice())
        }
        setVoice() {
            if (this.isSupported = !1, this.voices.length === 0) return;
            let e = this.voices.find(i => i.localService && i.lang.startsWith(this.lang));
            if (e) {
                this.speech.voice = e, this.isSupported = !0;
                return
            }
            let t = this.voices.find(i => i.lang.startsWith(this.lang));
            if (t) {
                this.speech.voice = t, this.isSupported = !0;
                return
            }
        }
        play() {
            this.speech.text = this.text, globalThis.speechSynthesis.speak(this.speech)
        }
        cancel() {
            globalThis.speechSynthesis.cancel()
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-text-to-speech"]
                ],
                inputs: {
                    lang: "lang",
                    text: "text"
                },
                features: [ve],
                decls: 1,
                vars: 1,
                consts: [
                    [4, "transloco", "translocoRead"],
                    ["fill", "clear", "shape", "round", "color", "dark", "matTooltipPosition", "above", 1, "circle-icon", 3, "matTooltip"],
                    ["fill", "clear", "shape", "round", "color", "medium", "matTooltipPosition", "above", 1, "circle-icon", 3, "matTooltip"],
                    ["fill", "clear", "shape", "round", "color", "dark", "matTooltipPosition", "above", 1, "circle-icon", 3, "click", "matTooltip"],
                    ["slot", "icon-only", "color", "primary", 3, "name"],
                    ["name", "volume-mute-outline", "slot", "icon-only"]
                ],
                template: function(t, i) {
                    t & 1 && g(0, So, 2, 1, "ng-container", 0), t & 2 && m("translocoRead", "text-to-speech")
                },
                dependencies: [z, Q, B, F, K],
                encapsulation: 2
            })
        }
    }
    return n
})();

function Io(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "span", 3), v("mouseenter", function() {
            let i = f(e).$index,
                a = r(3);
            return _(a.hoveredSentenceIndex = i)
        }), I(1), p()
    }
    if (n & 2) {
        let e = o.$implicit,
            t = o.$index,
            i = r(3);
        E("hover", i.hoveredSentenceIndex === t), c(), j(e)
    }
}

function Lo(n, o) {
    if (n & 1 && (l(0, "div", 1), ne(1, Io, 2, 3, "span", 2, de), p()), n & 2) {
        let e = r();
        c(), ie(e)
    }
}

function Oo(n, o) {
    n & 1 && g(0, Lo, 3, 0, "div", 1), n & 2 && b(o.length > 1 ? 0 : -1)
}
var aa = (() => {
    class n {
        constructor() {
            this.store = s(D), this.hoveredSentenceIndex = null, this.sentences$ = this.store.select(e => e.translate.spokenLanguageSentences)
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-desktop-textarea"]
                ],
                inputs: {
                    maxLength: "maxLength",
                    lang: "lang",
                    textControl: "textControl"
                },
                decls: 3,
                vars: 6,
                consts: [
                    ["id", "desktop", "enterkeyhint", "enter", "dir", "auto", "aria-labelledby", "spoken-language-label", "autofocus", "", "data-gramm_editor", "false", 3, "mouseleave", "formControl", "maxLength", "lang"],
                    ["id", "sentences-overlay"],
                    [3, "hover"],
                    [3, "mouseenter"]
                ],
                template: function(t, i) {
                    if (t & 1 && (l(0, "textarea", 0), v("mouseleave", function() {
                            return i.hoveredSentenceIndex = null
                        }), p(), g(1, Oo, 1, 1), C(2, "async")), t & 2) {
                        let a;
                        m("formControl", i.textControl)("maxLength", i.maxLength)("lang", i.lang), c(), b((a = x(2, 4, i.sentences$)) ? 1 : -1, a)
                    }
                },
                dependencies: [at, Ln, nt, it, Y],
                styles: [`[_nghost-%COMP%]{position:relative;display:block;width:100%;height:calc(100% - 40px)}*[_ngcontent-%COMP%]{direction:unset;font-family:Roboto,RobotoDraft,Helvetica,Arial,sans-serif;font-size:24px;line-height:32px}textarea#desktop[_ngcontent-%COMP%]{background-color:transparent;color:inherit;border:none;resize:none;outline:none;width:100%;height:100%}#sentences-overlay[_ngcontent-%COMP%]{position:absolute;color:transparent;cursor:text;white-space:pre-wrap;pointer-events:none;top:0;padding:2px}#sentences-overlay[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{pointer-events:all}#sentences-overlay[_ngcontent-%COMP%]   span.hover[_ngcontent-%COMP%]{border-bottom:1px solid var(--ion-color-warning-tint);pointer-events:none}
/*# sourceMappingURL=desktop-textarea.component-BWKNLNLD.css.map */`]
            })
        }
    }
    return n
})();

function Do(n, o) {
    if (n & 1) {
        let e = w();
        u(0, "ion-icon", 10), I(1), l(2, "a", 11), v("click", function() {
            f(e);
            let i = r(3);
            return _(i.setDetectedLanguage())
        }), I(3), C(4, "transloco"), p()
    }
    if (n & 2) {
        let e = r().$implicit,
            t = r(2);
        c(), H(" ", e("translate-from"), ": "), c(2), j(x(4, 2, "languages." + t.detectedLanguage))
    }
}

function Eo(n, o) {
    if (n & 1) {
        let e = w();
        u(0, "ion-icon", 10), I(1), l(2, "a", 11), v("click", function() {
            let i = f(e),
                a = r(3);
            return _(a.setText(i))
        }), I(3), p()
    }
    if (n & 2) {
        let e = r().$implicit;
        c(), H(" ", e("did-you-mean"), ": "), c(2), j(o)
    }
}

function Ro(n, o) {
    if (n & 1 && (l(0, "div", 9), g(1, Do, 5, 4)(2, Eo, 4, 2), C(3, "async"), p()), n & 2) {
        let e, t = r(2);
        c(), b(t.detectedLanguage && t.detectedLanguage !== t.spokenLanguage ? 1 : -1), c(), b((e = x(3, 2, t.normalizedText$)) ? 2 : -1, e)
    }
}

function Bo(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "div", 0)(1, "label", 2), I(2), C(3, "transloco"), p(), u(4, "app-desktop-textarea", 3), g(5, Ro, 4, 4, "div", 4), l(6, "div", 5)(7, "app-speech-to-text", 6), v("changeText", function(i) {
            f(e);
            let a = r();
            return _(a.text.setValue(i))
        }), p(), u(8, "app-text-to-speech", 7), l(9, "div", 8), I(10), C(11, "number"), C(12, "number"), p()()()
    }
    if (n & 2) {
        let e = r();
        c(2), j(x(3, 10, "translate.spoken-to-signed.text")), c(2), m("textControl", e.text)("maxLength", e.maxTextLength)("lang", e.spokenLanguage), c(), m("translocoRead", "translate.suggestions"), c(2), m("lang", e.spokenLanguage), c(), m("lang", e.spokenLanguage)("text", e.text.value), c(2), _n("", x(11, 12, e.text.value.length), " / ", x(12, 14, e.maxTextLength), "")
    }
}

function Fo(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-toolbar", 1)(1, "ion-buttons", 12)(2, "ion-button", 13), u(3, "ion-icon", 14), p()(), u(4, "ion-textarea", 15), C(5, "transloco"), C(6, "transloco"), l(7, "ion-buttons", 16)(8, "app-speech-to-text", 17), v("changeText", function(i) {
            f(e);
            let a = r();
            return _(a.text.setValue(i))
        }), p()()()
    }
    if (n & 2) {
        let e = r();
        c(4), m("placeholder", x(5, 7, "translate.spoken-to-signed.placeholder"))("formControl", e.text)("lang", e.spokenLanguage), k("aria-label", x(6, 9, "translate.spoken-to-signed.text"))("maxLength", e.maxTextLength)("data-gramm_editor", !1), c(4), m("lang", e.spokenLanguage)
    }
}
var Pt = (() => {
    class n extends $ {
        constructor() {
            super(), this.store = s(D), this.text = new On, this.maxTextLength = 500, this.isMobile = !1, this.translate$ = this.store.select(e => e.translate), this.text$ = this.store.select(e => e.translate.spokenLanguageText), this.normalizedText$ = this.store.select(e => e.translate.normalizedSpokenLanguageText), A({
                sparkles: pi,
                addOutline: Zn
            })
        }
        ngOnInit() {
            this.translate$.pipe(T(({
                spokenLanguage: e,
                detectedLanguage: t
            }) => {
                this.detectedLanguage = t, this.spokenLanguage = e ? ? t
            }), y(this.ngUnsubscribe)).subscribe(), this.text.valueChanges.pipe(Bt(() => Ne(300)), mn(e => !e), Ft((e, t) => e.trim() === t.trim()), T(e => this.store.dispatch(new Ee(e))), y(this.ngUnsubscribe)).subscribe(), this.text.valueChanges.pipe(Bt(() => Ne(1e3)), Ft((e, t) => e.trim() === t.trim()), T(e => this.store.dispatch(new Wn)), y(this.ngUnsubscribe)).subscribe(), this.text$.pipe(T(e => this.text.setValue(e)), y(this.ngUnsubscribe)).subscribe()
        }
        setText(e) {
            this.store.dispatch(new Ee(e))
        }
        setDetectedLanguage() {
            this.store.dispatch(new mt(this.detectedLanguage))
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-spoken-language-input"]
                ],
                inputs: {
                    isMobile: "isMobile"
                },
                features: [P],
                decls: 2,
                vars: 2,
                consts: [
                    [1, "translation-text"],
                    ["appKeyboardFlying", ""],
                    ["id", "spoken-language-label"],
                    ["dir", "auto", 3, "textControl", "maxLength", "lang"],
                    ["id", "suggestions", 4, "transloco", "translocoRead"],
                    [1, "actions-row"],
                    [3, "changeText", "lang"],
                    [3, "lang", "text"],
                    ["id", "char-count"],
                    ["id", "suggestions"],
                    ["name", "sparkles", "color", "primary"],
                    [3, "click"],
                    ["slot", "start"],
                    ["disabled", ""],
                    ["slot", "icon-only", "name", "add-outline", "color", "primary"],
                    ["id", "mobile", "autoGrow", "", "rows", "1", "enterkeyhint", "enter", "dir", "auto", "aria-labelledby", "spoken-language-label", "autofocus", "", 3, "placeholder", "formControl", "lang"],
                    ["slot", "end"],
                    ["matTooltipPosition", "before", 3, "changeText", "lang"]
                ],
                template: function(t, i) {
                    t & 1 && g(0, Bo, 13, 16, "div", 0)(1, Fo, 9, 11, "ion-toolbar", 1), t & 2 && (b(i.isMobile ? -1 : 0), c(), b(i.isMobile ? 1 : -1))
                },
                dependencies: [ke, De, B, F, Bn, aa, ia, at, nt, it, Z, Tn, St, Y, K],
                styles: [`.translation-text[_ngcontent-%COMP%]{position:relative;height:100%;padding:20px 24px;flex:1}.translation-text[_ngcontent-%COMP%] > .actions-row[_ngcontent-%COMP%]{display:flex}.translation-text[_ngcontent-%COMP%] > #suggestions[_ngcontent-%COMP%]{position:absolute;bottom:60px;width:100%;left:0;right:0;padding:0 24px}.translation-text[_ngcontent-%COMP%] > #suggestions[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{padding:0 4px}.translation-text[_ngcontent-%COMP%] > #suggestions[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{cursor:pointer}#spoken-language-label[_ngcontent-%COMP%]{display:none}#char-count[_ngcontent-%COMP%]{flex-grow:1;align-self:center;text-align:end;font-size:12px;line-height:40px;padding-inline:10px;white-space:nowrap}  html[dir=rtl] #char-count{direction:ltr;text-align:start!important}ion-textarea#mobile[_ngcontent-%COMP%]{margin-top:6px;margin-bottom:6px;border-radius:20px;--padding-start: 10px;--padding-bottom: var(--padding-top);--highlight-color: var(--ion-color-primary)}ion-textarea#mobile.sc-ion-textarea-ios-h[_ngcontent-%COMP%]{min-height:initial;background-color:#fff}@media (prefers-color-scheme: dark){ion-textarea#mobile.sc-ion-textarea-ios-h[_ngcontent-%COMP%]{background-color:#202124}}
/*# sourceMappingURL=spoken-language-input.component-Y765FOTT.css.map */`]
            })
        }
    }
    return n
})();
var Ao = (n, o) => o.fsw;

function Vo(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "fsw-sign", 3), v("dblclick", function() {
            let i = f(e).$implicit,
                a = r(2);
            return _(a.describeSign(i))
        }), p()
    }
    if (n & 2) {
        let e = o.$implicit;
        m("matTooltip", e.description), k("sign", e.fsw)
    }
}

function No(n, o) {
    if (n & 1 && (l(0, "div", 0), ne(1, Vo, 1, 2, "fsw-sign", 2, Ao), p()), n & 2) {
        let e = r();
        c(), ie(e.signs)
    }
}

function zo(n, o) {
    n & 1 && u(0, "ion-progress-bar", 1)
}
var It = (() => {
    class n {
        static {
            this.isCustomElementDefined = !1
        }
        constructor() {
            this.mediaMatcher = s(ft), this.store = s(D), this.signs = [], this.colorSchemeMedia = this.mediaMatcher.matchMedia("(prefers-color-scheme: dark)"), this.signs$ = this.store.select(e => e.translate.signWriting), this.listenToSigns(), this.listenToColorChange()
        }
        listenToColorChange() {
            R(this.colorSchemeMedia, "change").pipe(T(() => {
                let e = this.signs;
                this.signs = [], requestAnimationFrame(() => this.signs = e)
            }), zt()).subscribe()
        }
        listenToSigns() {
            this.signs$.pipe(T(e => {
                this.signs = e, e && e.length > 0 && this.loadSGNWComponents()
            }), zt()).subscribe()
        }
        loadSGNWComponents() {
            n.isCustomElementDefined || (n.isCustomElementDefined = !0, Yn.loadFonts().then().catch(),
                import ("./index.es2017-LGFK2MGU.js").then(({
                    defineCustomElements: e
                }) => e()).then().catch())
        }
        describeSign(e) {
            e.description || this.store.dispatch(new qn(e.fsw))
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-sign-writing"]
                ],
                decls: 2,
                vars: 1,
                consts: [
                    ["id", "signs"],
                    ["type", "indeterminate"],
                    [3, "matTooltip"],
                    [3, "dblclick", "matTooltip"]
                ],
                template: function(t, i) {
                    t & 1 && g(0, No, 3, 0, "div", 0)(1, zo, 1, 0, "ion-progress-bar", 1), t & 2 && b(i.signs ? 0 : 1)
                },
                dependencies: [ct, z, Q],
                styles: [`[_nghost-%COMP%]{text-align:center;overflow-y:auto;height:100%;position:relative;color:#000}@media (prefers-color-scheme: dark){[_nghost-%COMP%]{color:#fff}}#signs[_ngcontent-%COMP%]{padding:20px 0;width:100%;font-size:24px;position:absolute}fsw-sign[_ngcontent-%COMP%]{direction:ltr;display:block;margin:20px 0;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none}
/*# sourceMappingURL=sign-writing.component-2764QQIP.css.map */`]
            })
        }
    }
    return n
})();

function nn() {
    return "ManagedMediaSource" in window ? window.ManagedMediaSource : "MediaSource" in window ? MediaSource : "WebKitMediaSource" in window ? window.WebKitMediaSource : (console.warn("Neither ManagedMediaSource nor MediaSource are supported on this device"), null)
}
var he = class {
    constructor(o, e) {
        this.image = o, this.fps = e, this.frameBuffer = [], this.bitrate = 1e7, this.alpha = !0
    }
    static isSupported() {
        return "VideoEncoder" in globalThis
    }
    init() {
        return M(this, null, function*() {
            yield this.createWebMMuxer(), (yield this.isPlayable()) || (yield this.createMP4Muxer()), this.createVideoEncoder()
        })
    }
    isPlayable() {
        return M(this, null, function*() {
            if (!("navigator" in globalThis)) return !1;
            if (!("mediaCapabilities" in navigator)) {
                let t = nn();
                if (!t) return !1;
                let i = `video/${this.container}; codecs="${this.codec}"`;
                return t.isTypeSupported(i)
            }
            let o = {
                    contentType: `video/${this.container}; codecs="${this.codec}"`,
                    width: this.width,
                    height: this.height,
                    bitrate: this.bitrate,
                    framerate: this.fps,
                    hasAlphaChannel: this.alpha
                },
                {
                    supported: e
                } = yield navigator.mediaCapabilities.decodingInfo({
                    type: "file",
                    video: o
                });
            return e
        })
    }
    createWebMMuxer() {
        return M(this, null, function*() {
            let {
                Muxer: o,
                ArrayBufferTarget: e
            } = yield
            import ("./webm-muxer-BMDZCO2O.js");
            this.container = "webm", this.codec = "vp09.00.10.08", this.width = this.image.width, this.height = this.image.height, this.muxer = new o({
                target: new e,
                video: {
                    codec: "V_VP9",
                    width: this.width,
                    height: this.height,
                    frameRate: this.fps,
                    alpha: this.alpha
                }
            })
        })
    }
    createMP4Muxer() {
        return M(this, null, function*() {
            let {
                Muxer: o,
                ArrayBufferTarget: e
            } = yield
            import ("./mp4-muxer-4VH6VQAJ.js");
            this.container = "mp4", this.codec = "avc1.42001f", this.width = this.image.width + this.image.width % 2, this.height = this.image.height + this.image.height % 2, this.muxer = new o({
                target: new e,
                fastStart: "in-memory",
                video: {
                    codec: "avc",
                    width: this.width,
                    height: this.height
                }
            })
        })
    }
    createVideoEncoder() {
        this.videoEncoder = new VideoEncoder({
            output: (e, t) => this.muxer.addVideoChunk(e, t),
            error: e => console.error(e)
        });
        let o = {
            codec: this.codec,
            width: this.width,
            height: this.height,
            bitrate: this.bitrate,
            framerate: this.fps
        };
        this.videoEncoder.configure(o);
        for (let e of this.frameBuffer) this.encodeFrame(e);
        this.frameBuffer = []
    }
    addFrame(o, e) {
        let i = new VideoFrame(e, {
            timestamp: 1e6 * o / this.fps,
            duration: 1e6 / this.fps
        });
        this.videoEncoder ? this.encodeFrame(i) : this.frameBuffer.push(i)
    }
    encodeFrame(o) {
        this.videoEncoder.encode(o), o.close()
    }
    finalize() {
        return M(this, null, function*() {
            yield this.videoEncoder.flush(), this.muxer.finalize(), this.videoEncoder.close(), delete this.videoEncoder;
            let {
                buffer: o
            } = this.muxer.target;
            return new Blob([o], {
                type: `video/${this.container}`
            })
        })
    }
    close() {
        this.videoEncoder && (this.videoEncoder.close(), delete this.videoEncoder), this.muxer && delete this.muxer
    }
};

function Ho(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-fab-button", 6), v("click", function() {
            let i = f(e).$implicit,
                a = r(2);
            return _(a.applySetting("poseViewer", i.id))
        }), u(1, "ion-icon", 3), p()
    }
    if (n & 2) {
        let e = o.$implicit,
            t = r().$implicit;
        m("color", e.color)("matTooltip", t(e.id)), k("aria-label", t(e.id)), c(), m("name", e.icon)
    }
}

function Uo(n, o) {
    if (n & 1 && (ae(0), l(1, "ion-fab", 1)(2, "ion-fab-button", 2), u(3, "ion-icon", 3), p(), l(4, "ion-fab-list", 4), ne(5, Ho, 2, 4, "ion-fab-button", 5, de), p()(), oe()), n & 2) {
        let e = o.$implicit,
            t = r();
        c(2), m("color", t.fab.color)("matTooltip", e(t.fab.id)), k("aria-label", e(t.fab.id)), c(), m("name", t.fab.icon), c(2), ie(t.fabButtons)
    }
}
var oa = (() => {
    class n extends hi {
        constructor() {
            super(), this.poseViewerSetting$ = this.store.select(e => e.settings.poseViewer), this.buttons = [{
                id: "pose",
                icon: "git-commit",
                color: "light"
            }, {
                id: "avatar",
                icon: "logo-apple-ar",
                color: "success"
            }, {
                id: "person",
                icon: "accessibility",
                color: "primary"
            }], this.fabButtons = [], A({
                gitCommit: ai,
                logoAppleAr: si,
                accessibility: Kn
            })
        }
        ngOnInit() {
            this.poseViewerSetting$.pipe(T(e => {
                this.fabButtons = [];
                for (let t of this.buttons) t.id === e ? this.fab = t : this.fabButtons.push(t)
            }), y(this.ngUnsubscribe)).subscribe()
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-viewer-selector"]
                ],
                features: [P],
                decls: 1,
                vars: 1,
                consts: [
                    [4, "transloco", "translocoRead"],
                    ["id", "viewer-selector"],
                    ["size", "small", "matTooltipPosition", "before", 3, "color", "matTooltip"],
                    [3, "name"],
                    ["side", "bottom"],
                    ["matTooltipPosition", "before", 3, "color", "matTooltip"],
                    ["matTooltipPosition", "before", 3, "click", "color", "matTooltip"]
                ],
                template: function(t, i) {
                    t & 1 && g(0, Uo, 7, 4, "ng-container", 0), t & 2 && m("translocoRead", "settings.poseViewer")
                },
                dependencies: [Dn, En, rt, F, z, Q, K],
                styles: [`ion-fab#viewer-selector[_ngcontent-%COMP%]{top:0;right:0}  html[dir=rtl] ion-fab#viewer-selector{right:auto;left:0}
/*# sourceMappingURL=viewer-selector.component-GE2SPYLA.css.map */`]
            })
        }
    }
    return n
})();
var jo = ["poseViewer"],
    Fe = (() => {
        class n extends $ {
            constructor() {
                super(...arguments), this.store = s(D), this.poseEl = Ze("poseViewer"), this.background = "", this.mimeTypes = ["video/webm; codecs:vp9", "video/webm; codecs:vp8", "video/webm", "video/mp4", "video/ogv"], this.mediaSubscriptions = [], this.cache = [], this.frameIndex = 0
            }
            static {
                this.isCustomElementDefined = !1
            }
            ngOnInit() {
                return M(this, null, function*() {
                    if (!(Si && !he.isSupported())) {
                        let t = document.querySelector("app-signed-language-output");
                        t && (this.background = getComputedStyle(t).backgroundColor)
                    }
                    yield this.definePoseViewerElement()
                })
            }
            definePoseViewerElement() {
                return M(this, null, function*() {
                    if (!n.isCustomElementDefined) {
                        n.isCustomElementDefined = !0;
                        let {
                            defineCustomElements: e
                        } = yield
                        import ("./index.es2017-RZLBXEOY.js");
                        e()
                    }
                })
            }
            ngOnDestroy() {
                super.ngOnDestroy(), this.reset()
            }
            setVideo(e) {
                this.store.dispatch(new Nn(e))
            }
            fps() {
                return M(this, null, function*() {
                    return (yield this.poseEl().nativeElement.getPose()).body.fps
                })
            }
            initVideoEncoder(e) {
                return M(this, null, function*() {
                    let t = yield this.fps();
                    this.videoEncoder = new he(e, t), yield this.videoEncoder.init()
                })
            }
            createEncodedVideo() {
                return M(this, null, function*() {
                    let e = yield this.videoEncoder.finalize(), t = URL.createObjectURL(e);
                    this.setVideo(t)
                })
            }
            initMediaRecorder(e) {
                let t = [],
                    i;
                for (let L of this.mimeTypes)
                    if (MediaRecorder.isTypeSupported(L)) {
                        this.mediaRecorder = new MediaRecorder(e, {
                            mimeType: L,
                            videoBitsPerSecond: 1e9
                        }), i = L;
                        break
                    } else console.warn(L, "not supported");
                if (!i) return;
                let a = R(this.mediaRecorder, "dataavailable").pipe(T(L => t.push(L.data)), y(this.ngUnsubscribe));
                this.mediaSubscriptions.push(a.subscribe());
                let d = R(this.mediaRecorder, "stop").pipe(T(() => M(this, null, function*() {
                    e.getTracks().forEach(J => J.stop());
                    let L = new Blob(t, {
                        type: this.mediaRecorder.mimeType
                    });
                    console.log("blob", L.size, L.type);
                    let X = URL.createObjectURL(L);
                    this.setVideo(X)
                })), y(this.ngUnsubscribe));
                this.mediaSubscriptions.push(d.subscribe());
                let S = this.poseEl().nativeElement.duration * 1e3;
                this.mediaRecorder.start(S)
            }
            startRecording(e) {
                return M(this, null, function*() {
                    e.getContext("2d");
                    let t = yield this.fps(), i = e.captureStream(t);
                    this.initMediaRecorder(i)
                })
            }
            stopRecording() {
                if (this.videoEncoder) {
                    this.createEncodedVideo();
                    return
                }
                this.mediaRecorder && this.mediaRecorder.stop()
            }
            addCacheFrame(e) {
                return M(this, null, function*() {
                    he.isSupported() ? (this.videoEncoder || (yield this.initVideoEncoder(e)), this.videoEncoder.addFrame(this.frameIndex, e)) : this.cache.push(e), this.frameIndex++
                })
            }
            reset() {
                this.cacheSubscription && this.cacheSubscription.unsubscribe(), this.cache = [];
                for (let e of this.mediaSubscriptions) e.unsubscribe();
                this.mediaSubscriptions = [], this.mediaRecorder && (this.mediaRecorder.state !== "inactive" && this.mediaRecorder.stop(), delete this.mediaRecorder), this.videoEncoder && this.videoEncoder.close()
            }
            static {
                this.\u0275fac = (() => {
                    let e;
                    return function(i) {
                        return (e || (e = q(n)))(i || n)
                    }
                })()
            }
            static {
                this.\u0275cmp = h({
                    type: n,
                    selectors: [
                        ["app-pose-viewer"]
                    ],
                    viewQuery: function(t, i) {
                        t & 1 && Je(i.poseEl, jo, 5), t & 2 && et()
                    },
                    features: [P],
                    decls: 0,
                    vars: 0,
                    template: function(t, i) {},
                    encapsulation: 2
                })
            }
        }
        return n
    })();
var ra = (() => {
    class n extends Fe {
        constructor() {
            super(...arguments), this.effectiveFps = 1
        }
        ngAfterViewInit() {
            let e = this.poseEl().nativeElement;
            R(e, "firstRender$").pipe(T(() => M(this, null, function*() {
                let t = yield e.getPose();
                this.effectiveFps = t.body.fps
            })), y(this.ngUnsubscribe)).subscribe()
        }
        static {
            this.\u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })()
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-avatar-pose-viewer"]
                ],
                inputs: {
                    src: "src"
                },
                features: [P],
                decls: 3,
                vars: 4,
                consts: [
                    ["poseViewer", ""],
                    [3, "fps"],
                    ["width", "10px", "height", "10px"]
                ],
                template: function(t, i) {
                    t & 1 && u(0, "app-animation", 1)(1, "pose-viewer", 2, 0), t & 2 && (m("fps", i.effectiveFps), c(), k("src", i.src)("autoplay", !1)("loop", !1))
                },
                dependencies: [Pi],
                styles: [`[_nghost-%COMP%]{display:block}app-animation[_ngcontent-%COMP%]{display:block;width:100%;height:100%}pose-viewer[_ngcontent-%COMP%]{display:none}
/*# sourceMappingURL=avatar-pose-viewer.component-MX7SY76V.css.map */`]
            })
        }
    }
    return n
})();
var sa = (() => {
    class n extends Fe {
        ngAfterViewInit() {
            let e = this.poseEl().nativeElement;
            if (R(e, "firstRender$").pipe(T(() => M(this, null, function*() {
                    let t = e.shadowRoot.querySelector("canvas");
                    e.currentTime = 0, he.isSupported() || (yield this.startRecording(t))
                })), y(this.ngUnsubscribe)).subscribe(), he.isSupported()) {
                let t = NaN;
                R(e, "render$").pipe(T(() => M(this, null, function*() {
                    if (e.currentTime === t) return;
                    let i = e.shadowRoot.querySelector("canvas"),
                        a = yield createImageBitmap(i);
                    yield this.addCacheFrame(a), t = e.currentTime
                })), y(this.ngUnsubscribe)).subscribe()
            }
            R(e, "ended$").pipe(T(() => M(this, null, function*() {
                return this.stopRecording()
            })), y(this.ngUnsubscribe)).subscribe(), this.pauseInvisible()
        }
        pauseInvisible() {
            let e = this.poseEl().nativeElement;
            R(document, "visibilitychange").pipe(T(() => M(this, null, function*() {
                document.visibilityState === "visible" ? (yield e.play(), this.mediaRecorder && this.mediaRecorder.resume()) : (yield e.pause(), this.mediaRecorder && this.mediaRecorder.pause())
            })), y(this.ngUnsubscribe)).subscribe()
        }
        static {
            this.\u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })()
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-skeleton-pose-viewer"]
                ],
                inputs: {
                    src: "src"
                },
                features: [P],
                decls: 2,
                vars: 2,
                consts: [
                    ["poseViewer", ""],
                    ["autoplay", "true", "aspect-ratio", "1", "width", "100%"]
                ],
                template: function(t, i) {
                    t & 1 && u(0, "pose-viewer", 1, 0), t & 2 && k("background", i.background)("src", i.src)
                },
                styles: [`[_nghost-%COMP%]{display:block}pose-viewer[_ngcontent-%COMP%]{display:flex;width:100%;font-size:2em;align-items:center;justify-content:center;text-align:center;aspect-ratio:1}
/*# sourceMappingURL=skeleton-pose-viewer.component-M6BKLKYL.css.map */`]
            })
        }
    }
    return n
})();
var $o = ["canvas"];

function Qo(n, o) {
    if (n & 1 && u(0, "ion-progress-bar", 4), n & 2) {
        let e = r().$implicit,
            t = r();
        m("value", t.progress), k("aria-label", e("generating"))
    }
}

function Wo(n, o) {
    if (n & 1 && u(0, "ion-spinner", 5), n & 2) {
        let e = r().$implicit;
        m("matTooltip", e("loading"))
    }
}

function qo(n, o) {
    if (n & 1 && (ae(0), g(1, Qo, 1, 2, "ion-progress-bar", 4)(2, Wo, 1, 1, "ion-spinner", 5), u(3, "canvas", 6, 1), oe()), n & 2) {
        let e = r();
        c(), b(e.modelReady && !e.ready ? 1 : -1), c(), b(e.modelReady ? -1 : 2)
    }
}
var ca = (() => {
    class n extends Fe {
        constructor() {
            super(...arguments), this.pix2pix = s(Ii), this.appearance$ = this.store.select(e => e.settings.appearance), this.canvasEl = Ze("canvas"), this.ready = !1, this.modelReady = !1, this.totalFrames = 1
        }
        ngAfterViewInit() {
            let e = this.poseEl().nativeElement,
                t = this.canvasEl().nativeElement,
                i = t.getContext("2d"),
                a = !1;
            this.ngUnsubscribe.subscribe(() => a = !0), R(e, "firstRender$").pipe(T(() => M(this, null, function*() {
                this.reset(), this.totalFrames = (yield this.fps()) * e.duration, yield this.pix2pix.loadModel();
                let d = e.shadowRoot.querySelector("canvas"),
                    S = d.getContext("2d", {
                        willReadFrequently: !0
                    }),
                    L = 0,
                    X = () => M(this, null, function*() {
                        if (a) return;
                        if (e.ended) {
                            L === 0 && (this.ready = !0, yield this.drawCache());
                            return
                        }
                        L++, yield new Promise(requestAnimationFrame);
                        let J = yield Li(d, S);
                        yield e.nextFrame(), this.translateFrame(J, t, i).then(() => {
                            L--, X()
                        })
                    });
                for (let J = 0; J < 3; J++) yield X()
            })), y(this.ngUnsubscribe)).subscribe()
        }
        translateFrame(e, t, i) {
            return M(this, null, function*() {
                let a = yield this.pix2pix.translate(e);
                this.modelReady = !0;
                let d = new ImageData(a, t.width, t.height);
                i.putImageData(d, 0, 0);
                let S = yield createImageBitmap(d);
                yield this.addCacheFrame(S)
            })
        }
        drawFrame(e, t, i) {
            i.clearRect(0, 0, t.width, t.height), this.background && (i.fillStyle = this.background, i.fillRect(0, 0, t.width, t.height)), i.drawImage(e, 0, 0)
        }
        reset() {
            super.reset(), this.ready = !1
        }
        drawCache() {
            return M(this, null, function*() {
                if (this.videoEncoder) return this.stopRecording();
                if (this.cache.length === 0) return;
                let e = this.canvasEl().nativeElement;
                yield this.startRecording(e);
                let t = e.getContext("2d"),
                    i = yield this.fps(), a = -1;
                this.cacheSubscription = Ne(1e3 / i).pipe(T(() => {
                    a++, a < this.cache.length ? (this.drawFrame(this.cache[a], e, t), delete this.cache[a]) : (this.cacheSubscription.unsubscribe(), this.stopRecording())
                }), y(this.ngUnsubscribe)).subscribe()
            })
        }
        get progress() {
            let e = this.poseEl();
            return !e || !e.nativeElement.duration ? 0 : this.frameIndex / this.totalFrames
        }
        static {
            this.\u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })()
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-human-pose-viewer"]
                ],
                viewQuery: function(t, i) {
                    t & 1 && Je(i.canvasEl, $o, 5), t & 2 && et()
                },
                inputs: {
                    src: "src",
                    width: "width",
                    height: "height"
                },
                features: [P],
                decls: 4,
                vars: 7,
                consts: [
                    ["poseViewer", ""],
                    ["canvas", ""],
                    ["thickness", "1", "width", "256px", "height", "256px"],
                    [4, "transloco", "translocoRead"],
                    [3, "value"],
                    ["color", "primary", 3, "matTooltip"],
                    ["width", "768", "height", "768"]
                ],
                template: function(t, i) {
                    t & 1 && (u(0, "pose-viewer", 2, 0), C(2, "async"), g(3, qo, 5, 2, "ng-container", 3)), t & 2 && (k("src", i.src)("autoplay", !1)("loop", !1)("background", x(2, 5, i.appearance$)), c(3), m("translocoRead", "translate.spoken-to-signed.progress-bars.human-pose-viewer"))
                },
                dependencies: [ct, lt, Y, z, Q, K],
                styles: [`[_nghost-%COMP%]{display:flex;height:100%}pose-viewer[_ngcontent-%COMP%]{display:none}canvas[_ngcontent-%COMP%]{width:100%;display:block;align-self:center}ion-progress-bar[_ngcontent-%COMP%]{position:absolute}ion-spinner[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%) translateY(-50%)}
/*# sourceMappingURL=human-pose-viewer.component-WCMG7K7V.css.map */`]
            })
        }
    }
    return n
})();

function Go(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "video", 1), v("error", function(i) {
            f(e);
            let a = r();
            return _(a.onVideoError(i))
        })("click", function(i) {
            f(e);
            let a = r();
            return _(a.playVideoIfPaused(i))
        }), p()
    }
    if (n & 2) {
        let e = r();
        m("src", e.safeVideoUrl, bn)
    }
}

function Yo(n, o) {
    if (n & 1 && u(0, "app-skeleton-pose-viewer", 2), n & 2) {
        let e = r(2);
        m("src", e)
    }
}

function Ko(n, o) {
    if (n & 1 && u(0, "app-human-pose-viewer", 2), n & 2) {
        let e = r(2);
        m("src", e)
    }
}

function Zo(n, o) {
    if (n & 1 && u(0, "app-avatar-pose-viewer", 2), n & 2) {
        let e = r(2);
        m("src", e)
    }
}

function Xo(n, o) {
    if (n & 1 && g(0, Yo, 1, 1, "app-skeleton-pose-viewer", 2)(1, Ko, 1, 1, "app-human-pose-viewer", 2)(2, Zo, 1, 1, "app-avatar-pose-viewer", 2), n & 2) {
        let e = o;
        b(e === "pose" ? 0 : e === "person" ? 1 : e === "avatar" ? 2 : -1)
    }
}

function Jo(n, o) {
    if (n & 1 && (g(0, Xo, 3, 1), C(1, "async")), n & 2) {
        let e, t = r(2);
        b((e = x(1, 1, t.poseViewerSetting$)) ? 0 : -1, e)
    }
}

function er(n, o) {
    if (n & 1 && (g(0, Jo, 2, 3), C(1, "async")), n & 2) {
        let e, t = r();
        b((e = x(1, 1, t.pose$)) ? 0 : -1, e)
    }
}

function tr(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-button", 5), C(1, "transloco"), C(2, "transloco"), v("click", function() {
            f(e);
            let i = r(3);
            return _(i.shareTranslation())
        }), u(3, "ion-icon", 8), p()
    }
    n & 2 && (m("matTooltip", x(1, 3, "translate.spoken-to-signed.actions.share"))("matTooltipPosition", "above"), k("aria-label", x(2, 5, "translate.spoken-to-signed.actions.share")))
}

function nr(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-button", 5), C(1, "transloco"), C(2, "transloco"), v("click", function() {
            f(e);
            let i = r(2);
            return _(i.downloadTranslation())
        }), u(3, "ion-icon", 6), p(), g(4, tr, 4, 7, "ion-button", 7)
    }
    if (n & 2) {
        let e = r(2);
        m("matTooltip", x(1, 4, "translate.spoken-to-signed.actions.download"))("matTooltipPosition", "above"), k("aria-label", x(2, 6, "translate.spoken-to-signed.actions.download")), c(4), b(e.isSharingSupported ? 4 : -1)
    }
}

function ir(n, o) {
    n & 1 && (l(0, "ion-button", 4), u(1, "ion-spinner", 9), p()), n & 2 && m("disabled", !0)
}

function ar(n, o) {
    if (n & 1 && (l(0, "div", 3), g(1, nr, 5, 8)(2, ir, 2, 1, "ion-button", 4), p(), u(3, "app-viewer-selector")), n & 2) {
        let e = r();
        c(), b(e.videoUrl ? 1 : 2)
    }
}
var Lt = (() => {
    class n extends $ {
        constructor() {
            super(), this.store = s(D), this.domSanitizer = s(Pn), this.poseViewerSetting$ = this.store.select(e => e.settings.poseViewer), this.pose$ = this.store.select(e => e.translate.signedLanguagePose), this.video$ = this.store.select(e => e.translate.signedLanguageVideo), this.isSharingSupported = kn.isNativePlatform() || "navigator" in globalThis && "share" in navigator, A({
                downloadOutline: ni,
                shareOutline: li,
                shareSocialOutline: di
            })
        }
        ngOnInit() {
            this.video$.pipe(T(e => {
                this.videoUrl = e, this.safeVideoUrl = e ? this.domSanitizer.bypassSecurityTrustUrl(e) : null
            }), y(this.ngUnsubscribe)).subscribe()
        }
        copyTranslation() {
            this.store.dispatch(Hn)
        }
        downloadTranslation() {
            this.store.dispatch($n)
        }
        shareTranslation() {
            this.store.dispatch(jn)
        }
        playVideoIfPaused(e) {
            let t = e.target;
            t.paused && t.play().then().catch()
        }
        createVideoMediaSource() {
            return M(this, null, function*() {
                let t = yield(yield fetch(this.videoUrl)).blob(), i = nn();
                if (!i) return null;
                let a = new i;
                return a.addEventListener("sourceopen", () => M(this, null, function*() {
                    let d = a.addSourceBuffer(t.type);
                    d.addEventListener("updateend", () => {
                        !d.updating && a.readyState === "open" && a.endOfStream()
                    }), d.appendBuffer(yield t.arrayBuffer())
                })), a
            })
        }
        onVideoError(e) {
            return M(this, null, function*() {
                if (this.safeVideoUrl === null) return;
                let t = e.target;
                t.srcObject || (this.safeVideoUrl = null, t.disableRemotePlayback = !0, t.srcObject = yield this.createVideoMediaSource())
            })
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-signed-language-output"]
                ],
                features: [P],
                decls: 4,
                vars: 4,
                consts: [
                    ["autoplay", "", "loop", "", "muted", "", "playsinline", "", "height", "100%", "width", "100%", 3, "src"],
                    ["autoplay", "", "loop", "", "muted", "", "playsinline", "", "height", "100%", "width", "100%", 3, "error", "click", "src"],
                    [3, "src"],
                    [1, "actions-row"],
                    ["fill", "clear", "shape", "round", 1, "circle-icon", 3, "disabled"],
                    ["fill", "clear", "shape", "round", "color", "dark", 1, "circle-icon", 3, "click", "matTooltip", "matTooltipPosition"],
                    ["name", "download-outline", "slot", "icon-only"],
                    ["fill", "clear", "shape", "round", "color", "dark", 1, "circle-icon", 3, "matTooltip", "matTooltipPosition"],
                    ["ios", "share-outline", "md", "share-social-outline", "slot", "icon-only"],
                    ["name", "crescent", "color", "dark"]
                ],
                template: function(t, i) {
                    if (t & 1 && (g(0, Go, 1, 1, "video", 0)(1, er, 2, 3)(2, ar, 4, 1), C(3, "async")), t & 2) {
                        let a;
                        b(i.videoUrl ? 0 : 1), c(2), b((a = x(3, 2, i.pose$)) ? 2 : -1, a)
                    }
                },
                dependencies: [lt, B, oa, ra, sa, ca, Z, Y, z, Q, F],
                styles: [`[_nghost-%COMP%]{background-color:#fff;position:relative;aspect-ratio:1}@media screen and (min-width: 600px){[_nghost-%COMP%]{background-color:#f5f5f5}}@media (prefers-color-scheme: dark){[_nghost-%COMP%]{background-color:#202124}}app-skeleton-pose-viewer[_ngcontent-%COMP%]{height:100%;display:flex;align-items:center}video[_ngcontent-%COMP%]{display:block}
/*# sourceMappingURL=signed-language-output.component-AWTWMOC6.css.map */`]
            })
        }
    }
    return n
})();
var la = (() => {
    class n {
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-spoken-to-signed"]
                ],
                decls: 3,
                vars: 0,
                template: function(t, i) {
                    t & 1 && u(0, "app-spoken-language-input")(1, "app-sign-writing")(2, "app-signed-language-output")
                },
                dependencies: [Pt, It, Lt],
                styles: [`[_nghost-%COMP%]{display:grid;width:100%;grid-template-areas:"spoken signwriting signed";grid-template-columns:auto 100px 50%}@media screen and (max-width: 599px){[_nghost-%COMP%]{grid-template-areas:"signed signed" "spoken signwriting";grid-template-columns:auto 100px}[_nghost-%COMP%]   app-signed-language-output[_ngcontent-%COMP%]{border-bottom:1px solid var(--app-divider-color)}}[_nghost-%COMP%] > *[_ngcontent-%COMP%]:not(:last-child){border-inline-end:1px solid var(--app-divider-color)}@media screen and (max-width: 599px){app-sign-writing[_ngcontent-%COMP%]{border:none!important;height:195px}}app-signed-language-output[_ngcontent-%COMP%]{grid-area:signed}
/*# sourceMappingURL=spoken-to-signed.component-ZUDXYHHC.css.map */`]
            })
        }
    }
    return n
})();

function or(n, o) {
    if (n & 1) {
        let e = w();
        ae(0), l(1, "h3"), I(2), p(), l(3, "p"), I(4), p(), l(5, "ion-button", 1), v("click", function() {
            f(e);
            let i = r(2);
            return _(i.upload())
        }), I(6), p(), oe()
    }
    if (n & 2) {
        let e = o.$implicit;
        c(2), j(e("title")), c(2), j(e("types")), c(2), H(" ", e("browse"), " ")
    }
}

function rr(n, o) {
    n & 1 && g(0, or, 7, 3, "ng-container", 0), n & 2 && m("translocoRead", "translate.upload")
}

function sr(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "ion-button", 1), v("click", function() {
            f(e);
            let i = r();
            return _(i.upload())
        }), u(1, "ion-icon", 2), p()
    }
}
var Ot = (() => {
    class n {
        constructor() {
            this.store = s(D), this.isMobile = !1, this.uploadEl = document.createElement("input"), this.uploadEl.setAttribute("type", "file"), this.uploadEl.setAttribute("accept", "video/*"), this.uploadEl.addEventListener("change", this.onFileUpload.bind(this)), A({
                imagesOutline: oi
            })
        }
        upload() {
            this.uploadEl.click()
        }
        onFileUpload() {
            let e = this.uploadEl.files[0];
            if (e) {
                let t = (window.URL || window.webkitURL).createObjectURL(e);
                this.store.dispatch(new Gn(t))
            }
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-upload"]
                ],
                inputs: {
                    isMobile: "isMobile"
                },
                decls: 2,
                vars: 1,
                consts: [
                    [4, "transloco", "translocoRead"],
                    [3, "click"],
                    ["name", "images-outline", "slot", "icon-only"]
                ],
                template: function(t, i) {
                    t & 1 && g(0, rr, 1, 1, "ng-container")(1, sr, 2, 0, "ion-button"), t & 2 && b(i.isMobile ? 1 : 0)
                },
                dependencies: [B, F, K],
                styles: [`h3[_ngcontent-%COMP%]{font-family:Google Sans,sans-serif;font-size:24px;font-weight:400;line-height:30px;margin:0}p[_ngcontent-%COMP%]{color:#0000008a;font-size:14px;font-weight:400;margin-top:8px;margin-bottom:26px}@media (prefers-color-scheme: dark){p[_ngcontent-%COMP%]{color:#ffffffb3}}button[_ngcontent-%COMP%]{font-family:Google Sans,sans-serif;font-size:14px;font-weight:500;letter-spacing:.3px}
/*# sourceMappingURL=upload.component-GSO2JS6C.css.map */`]
            })
        }
    }
    return n
})();

function lr(n, o) {
    n & 1 && u(0, "app-upload")
}

function dr(n, o) {
    n & 1 && At(0)
}

function pr(n, o) {
    if (n & 1 && g(0, dr, 1, 0, "ng-container", 1), n & 2) {
        r(4);
        let e = me(3);
        m("ngTemplateOutlet", e)
    }
}

function mr(n, o) {
    n & 1 && g(0, lr, 1, 0, "app-upload")(1, pr, 1, 1, "ng-container"), n & 2 && b(o.src ? 1 : 0)
}

function ur(n, o) {
    if (n & 1 && (g(0, mr, 2, 1), C(1, "async")), n & 2) {
        let e, t = r(2);
        b((e = x(1, 1, t.videoState$)) ? 0 : -1, e)
    }
}

function gr(n, o) {
    n & 1 && At(0)
}

function br(n, o) {
    if (n & 1 && g(0, gr, 1, 0, "ng-container", 1), n & 2) {
        r(2);
        let e = me(3);
        m("ngTemplateOutlet", e)
    }
}

function hr(n, o) {
    if (n & 1 && g(0, ur, 2, 3)(1, br, 1, 1, "ng-container"), n & 2) {
        let e;
        b((e = o) === "upload" ? 0 : e === "webcam" ? 1 : -1)
    }
}

function fr(n, o) {
    if (n & 1) {
        let e = w();
        l(0, "div"), u(1, "app-text-to-speech", 6), C(2, "async"), l(3, "ion-button", 7), C(4, "transloco"), C(5, "transloco"), v("click", function() {
            f(e);
            let i = r(3);
            return _(i.copyTranslation())
        }), u(6, "ion-icon", 8), p()()
    }
    if (n & 2) {
        let e = r(),
            t = r(2);
        c(), m("lang", x(2, 5, t.spokenLanguage$))("text", e), c(2), m("matTooltip", x(4, 7, "translate.signed-to-spoken.actions.copy"))("matTooltipPosition", "above"), k("aria-label", x(5, 9, "translate.signed-to-spoken.actions.copy"))
    }
}

function _r(n, o) {
    if (n & 1 && (l(0, "div", 5)(1, "div"), I(2), p(), g(3, fr, 7, 11, "div"), p()), n & 2) {
        let e = o;
        c(2), j(e), c(), b(e !== "" ? 3 : -1)
    }
}

function vr(n, o) {
    if (n & 1 && (l(0, "div", 2)(1, "div", 3), u(2, "app-video", 4), p(), u(3, "app-sign-writing"), g(4, _r, 4, 2, "div", 5), C(5, "async"), p()), n & 2) {
        let e, t = r();
        c(2), m("displayControls", !1)("displayFps", !1), c(2), b((e = x(5, 3, t.spokenLanguageText$)) ? 4 : -1, e)
    }
}
var yr = [{
        time: .618368,
        sw: ["M507x523S15a28494x496"],
        text: "B"
    }, {
        time: .876432,
        sw: ["M507x523S15a28494x496S26500493x477"],
        text: "Your"
    }, {
        time: 1.102468,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S115494"],
        text: "Your h"
    }, {
        time: 1.102468,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491"],
        text: "Your h"
    }, {
        time: 1.438297,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S11549479x498"],
        text: "Your"
    }, {
        time: 1.628503,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S11549479x498S20500489x476"],
        text: "Your"
    }, {
        time: 1.786967,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S11549479x498S20600489x476"],
        text: "Your name"
    }, {
        time: 1.993408,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S11549479x498S20600489x476", "M554x585S30a00481x488S14c39465x545S14c31508x546"],
        text: "Your name"
    }, {
        time: 2.163386,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S11549479x498S20600489x476", "M554x585S30a00481x488S30300481x477S14c31508x546S14c39465x545S26506539x545S26512445x545"],
        text: "Your name"
    }, {
        time: 3.113322,
        sw: ["M507x523S15a28494x496S26500493x477", "M522x525S11541498x491S11549479x498S20600489x476", "M554x585S30a00481x488S30300481x477S14c31508x546S14c39465x545S27102539x545S27116445x545"],
        text: "What is your name?"
    }],
    da = (() => {
        class n {
            constructor() {
                this.store = s(D), this.videoState$ = this.store.select(e => e.video), this.inputMode$ = this.store.select(e => e.translate.inputMode), this.spokenLanguage$ = this.store.select(e => e.translate.spokenLanguage), this.spokenLanguageText$ = this.store.select(e => e.translate.spokenLanguageText), this.store.dispatch(new Ee("")), A({
                    copyOutline: ti
                })
            }
            ngOnInit() {
                let e = [],
                    t = "",
                    i = () => {
                        let a = document.querySelector("video");
                        if (a) {
                            let d = [],
                                S = "";
                            for (let L of yr) L.time <= a.currentTime && (S = L.text, d = L.sw);
                            S !== t && (this.store.dispatch(new Ee(S)), t = S), JSON.stringify(d) !== JSON.stringify(e) && (this.store.dispatch(new zn(d)), e = d)
                        }
                        requestAnimationFrame(i)
                    };
                i()
            }
            copyTranslation() {
                this.store.dispatch(Un)
            }
            static {
                this.\u0275fac = function(t) {
                    return new(t || n)
                }
            }
            static {
                this.\u0275cmp = h({
                    type: n,
                    selectors: [
                        ["app-signed-to-spoken"]
                    ],
                    decls: 4,
                    vars: 3,
                    consts: [
                        ["translationTemplate", ""],
                        [4, "ngTemplateOutlet"],
                        [1, "interface"],
                        [1, "sign-language"],
                        [3, "displayControls", "displayFps"],
                        [1, "translation-text"],
                        [3, "lang", "text"],
                        ["fill", "clear", "shape", "round", "color", "dark", 1, "circle-icon", 3, "click", "matTooltip", "matTooltipPosition"],
                        ["name", "copy-outline", "slot", "icon-only"]
                    ],
                    template: function(t, i) {
                        if (t & 1 && (g(0, hr, 2, 1), C(1, "async"), g(2, vr, 6, 5, "ng-template", null, 0, xn)), t & 2) {
                            let a;
                            b((a = x(1, 1, i.inputMode$)) ? 0 : -1, a)
                        }
                    },
                    dependencies: [z, Q, It, B, St, kt, xt, Ot, F, Z, Y, Mn],
                    styles: [`[_nghost-%COMP%]{display:flex}.interface[_ngcontent-%COMP%]{display:grid;width:100%;grid-template-areas:"signed spoken signwriting";grid-template-columns:50% 100px auto}@media screen and (max-width: 599px){.interface[_ngcontent-%COMP%]{grid-template-areas:"signed signed" "spoken signwriting";grid-template-columns:100px auto}}.interface[_ngcontent-%COMP%]   app-sign-writing[_ngcontent-%COMP%]{border-inline-end:1px solid var(--app-divider-color)}@media screen and (max-width: 599px){.interface[_ngcontent-%COMP%]   app-sign-writing[_ngcontent-%COMP%]{height:235px}}.sign-language[_ngcontent-%COMP%]{grid-area:signed}.translation-text[_ngcontent-%COMP%]{font-family:Roboto,RobotoDraft,Helvetica,Arial,sans-serif;padding:20px 58px 20px 24px;color:#878787;font-size:24px;line-height:32px;flex:1;display:flex;flex-direction:column;min-height:150px}.translation-text[_ngcontent-%COMP%]   [_ngcontent-%COMP%]:first-child{flex-grow:1}app-upload[_ngcontent-%COMP%]{text-align:center;padding:43px 16px 65px;width:100%}app-video[_ngcontent-%COMP%]{width:100%}
/*# sourceMappingURL=signed-to-spoken.component-3EQ3ZRMM.css.map */`]
                })
            }
        }
        return n
    })();
var pa = (() => {
    class n {
        constructor() {
            this.dropped = Te(), this.hovered = Te()
        }
        onDrop(e) {
            e.preventDefault(), this.dropped.emit(e.dataTransfer ? .files), this.hovered.emit(!1)
        }
        onDragOver(e) {
            e.preventDefault(), this.hovered.emit(!0)
        }
        onDragLeave(e) {
            e.preventDefault(), this.hovered.emit(!1)
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275dir = te({
                type: n,
                selectors: [
                    ["", "appDropzone", ""]
                ],
                hostBindings: function(t, i) {
                    t & 1 && v("drop", function(d) {
                        return i.onDrop(d)
                    })("dragover", function(d) {
                        return i.onDragOver(d)
                    })("dragleave", function(d) {
                        return i.onDragLeave(d)
                    })
                },
                outputs: {
                    dropped: "dropped",
                    hovered: "hovered"
                }
            })
        }
    }
    return n
})();
var Cr = ["*"],
    ma = (() => {
        class n {
            constructor() {
                this.store = s(D), this.isHovering = !1, this.listenExternalFileOpen()
            }
            listenExternalFileOpen() {
                "window" in globalThis && "launchQueue" in window && window.launchQueue.setConsumer(e => M(this, null, function*() {
                    if (!e.files.length) return;
                    let t = yield Promise.all(e.files.map(i => i.getFile()));
                    yield this.onDrop(t)
                }))
            }
            toggleHover(e) {
                this.isHovering = e
            }
            onDrop(e) {
                return M(this, null, function*() {
                    let t = e[0];
                    if (!t.name.endsWith(".pose")) {
                        alert("Please select a .pose file");
                        return
                    }
                    let i = URL.createObjectURL(t);
                    this.store.dispatch(new Qn(i))
                })
            }
            static {
                this.\u0275fac = function(t) {
                    return new(t || n)
                }
            }
            static {
                this.\u0275cmp = h({
                    type: n,
                    selectors: [
                        ["app-drop-pose-file"]
                    ],
                    hostVars: 2,
                    hostBindings: function(t, i) {
                        t & 2 && E("hovering", i.isHovering)
                    },
                    ngContentSelectors: Cr,
                    decls: 2,
                    vars: 0,
                    consts: [
                        ["appDropzone", "", 3, "hovered", "dropped"]
                    ],
                    template: function(t, i) {
                        t & 1 && (ue(), l(0, "div", 0), v("hovered", function(d) {
                            return i.toggleHover(d)
                        })("dropped", function(d) {
                            return i.onDrop(d)
                        }), pe(1), p())
                    },
                    dependencies: [pa],
                    styles: [`.hovering[_nghost-%COMP%]{filter:blur(3px)}[_nghost-%COMP%], div[_ngcontent-%COMP%]{height:100%}
/*# sourceMappingURL=drop-pose-file.component-CV5HKCST.css.map */`]
                })
            }
        }
        return n
    })();

function xr(n, o) {
    n & 1 && u(0, "app-translate-input-button", 7)
}

function kr(n, o) {
    n & 1 && u(0, "app-translate-input-button", 10)(1, "app-translate-input-button", 11)
}

function Mr(n, o) {
    n & 1 && u(0, "app-spoken-to-signed")
}

function Tr(n, o) {
    n & 1 && u(0, "app-signed-to-spoken")
}
var Dt = (() => {
    class n extends $ {
        constructor() {
            super(), this.store = s(D), this.spokenToSigned$ = this.store.select(e => e.translate.spokenToSigned), A({
                language: ri,
                videocam: ui,
                cloudUpload: ei
            })
        }
        ngOnInit() {
            this.spokenToSigned$.pipe(T(e => this.spokenToSigned = e), y(this.ngUnsubscribe)).subscribe()
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-translate-desktop"]
                ],
                features: [P],
                decls: 21,
                vars: 10,
                consts: [
                    [3, "translucent"],
                    ["slot", "primary"],
                    ["routerLink", "/about", "queryParamsHandling", "preserve", "color", "primary", "shape", "round", "fill", "solid"],
                    [3, "text"],
                    [3, "fullscreen"],
                    [1, "container"],
                    ["id", "input-mode-group"],
                    ["mode", "text", "icon", "language"],
                    ["id", "translation-card"],
                    ["id", "content"],
                    ["mode", "webcam", "icon", "videocam"],
                    ["mode", "upload", "icon", "cloud-upload"]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "ion-header", 0)(1, "ion-toolbar")(2, "ion-buttons", 1)(3, "ion-button", 2), I(4), C(5, "transloco"), p()(), l(6, "ion-title"), u(7, "app-logo", 3), C(8, "transloco"), p()()(), l(9, "ion-content", 4)(10, "div", 5)(11, "div", 6), g(12, xr, 1, 0, "app-translate-input-button", 7)(13, kr, 2, 0), p(), l(14, "app-drop-pose-file")(15, "div", 8), u(16, "app-language-selectors"), l(17, "div", 9), g(18, Mr, 1, 0, "app-spoken-to-signed")(19, Tr, 1, 0, "app-signed-to-spoken"), p()()(), u(20, "app-send-feedback"), p()()), t & 2 && (m("translucent", !0), c(4), H(" ", x(5, 6, "landing.about.title"), " "), c(3), m("text", x(8, 8, "translate.logo")), c(2), m("fullscreen", !0), c(3), b(i.spokenToSigned ? 12 : 13), c(6), b(i.spokenToSigned ? 18 : 19))
                },
                dependencies: [st, ke, De, ot, dt, Ei, wt, na, Z, la, da, ma, B, In, Oi],
                styles: [`@media screen and (min-width: 600px){.container[_ngcontent-%COMP%]:before{background-color:var(--app-tinted-background-color);border-bottom:1px solid var(--app-divider-color);content:"";display:block;height:106px;width:100%;position:absolute;z-index:-1;left:0}}.container[_ngcontent-%COMP%]{transition:.6s all cubic-bezier(.4,0,.2,1)}@media screen and (min-width: 1200px){.container[_ngcontent-%COMP%]{padding:0 48px 48px}}.container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]{height:68px;font-family:Google Sans,Roboto,Arial,sans-serif;align-items:center;display:flex;gap:.5em}@media screen and (max-width: 1279px){.container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]{padding:0 12px}}@media screen and (max-width: 599px){.container[_ngcontent-%COMP%]   #input-mode-group[_ngcontent-%COMP%]{display:none}}.container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{background-color:#fff;width:100%;height:100%;transition:.6s width cubic-bezier(.4,0,.2,1);box-shadow:0 0 2px #0000005e}@media (prefers-color-scheme: dark){.container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{background-color:#101010}}@media screen and (min-width: 600px){.container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{box-shadow:0 0 4px #0000005e}}@media screen and (min-width: 1200px){.container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]{border-radius:8px;overflow:hidden}}.container[_ngcontent-%COMP%]   #translation-card[_ngcontent-%COMP%]   app-language-selectors[_ngcontent-%COMP%]{border-bottom:1px solid var(--app-divider-color)}ntkme-github-button[_ngcontent-%COMP%]{margin:0 8px}#version[_ngcontent-%COMP%]{cursor:help;font-family:monospace}
/*# sourceMappingURL=translate-desktop.component-RRON3FT6.css.map */`]
            })
        }
    }
    return n
})();
var ua = (() => {
    class n {
        constructor() {
            A({
                ellipseOutline: ii,
                cameraReverseOutline: Xn
            })
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-signed-language-input"]
                ],
                decls: 9,
                vars: 1,
                consts: [
                    ["slot", "start"],
                    [3, "isMobile"],
                    ["color", "danger"],
                    ["name", "ellipse-outline"],
                    ["slot", "end"],
                    ["name", "camera-reverse-outline", "slot", "icon-only"]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "ion-toolbar")(1, "ion-buttons", 0), u(2, "app-upload", 1), p(), l(3, "ion-title")(4, "ion-fab-button", 2), u(5, "ion-icon", 3), p()(), l(6, "ion-buttons", 4)(7, "ion-button"), u(8, "ion-icon", 5), p()()()), t & 2 && (c(2), m("isMobile", !0))
                },
                dependencies: [ke, De, B, rt, dt, F, Ot],
                styles: [`ion-toolbar[_ngcontent-%COMP%]{--background: transparent;height:5em}ion-title[_ngcontent-%COMP%]{text-align:center}ion-title[_ngcontent-%COMP%]   ion-fab-button[_ngcontent-%COMP%]{margin:auto;--box-shadow: none}ion-title[_ngcontent-%COMP%]   ion-fab-button[_ngcontent-%COMP%]   ion-icon[_ngcontent-%COMP%]{font-size:5em}
/*# sourceMappingURL=signed-language-input.component-MHXA3XQI.css.map */`]
            })
        }
    }
    return n
})();

function wr(n, o) {
    n & 1 && u(0, "app-signed-language-output")
}

function Sr(n, o) {
    n & 1 && u(0, "app-video", 2), n & 2 && m("displayControls", !1)("displayFps", !1)
}

function Pr(n, o) {
    n & 1 && u(0, "app-spoken-language-input", 3), n & 2 && m("isMobile", !0)
}

function Ir(n, o) {
    n & 1 && u(0, "app-signed-language-input")
}
var ga = (() => {
    class n extends Dt {
        static {
            this.\u0275fac = (() => {
                let e;
                return function(i) {
                    return (e || (e = q(n)))(i || n)
                }
            })()
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-translate-mobile"]
                ],
                features: [P],
                decls: 9,
                vars: 6,
                consts: [
                    [3, "translucent"],
                    [3, "fullscreen"],
                    [3, "displayControls", "displayFps"],
                    [3, "isMobile"]
                ],
                template: function(t, i) {
                    t & 1 && (l(0, "ion-header", 0)(1, "ion-toolbar"), u(2, "app-language-selectors"), p()(), l(3, "ion-content", 1), g(4, wr, 1, 0, "app-signed-language-output")(5, Sr, 1, 2, "app-video", 2), p(), l(6, "ion-footer"), g(7, Pr, 1, 1, "app-spoken-language-input", 3)(8, Ir, 1, 0, "app-signed-language-input"), p()), t & 2 && (m("translucent", !0), c(3), m("fullscreen", !0), c(), b(i.spokenToSigned ? 4 : 5), c(2), E("signed-to-spoken", !i.spokenToSigned), c(), b(i.spokenToSigned ? 7 : 8))
                },
                dependencies: [ot, st, ke, Rn, Lt, ua, Pt, kt, xt, wt],
                styles: [`app-signed-language-output[_ngcontent-%COMP%]{display:block;width:100%;height:100%}ion-footer.signed-to-spoken[_ngcontent-%COMP%]{box-shadow:none}
/*# sourceMappingURL=translate-mobile.component-526GGSGJ.css.map */`]
            })
        }
    }
    return n
})();

function Lr(n, o) {
    n & 1 && u(0, "app-translate-mobile")
}

function Or(n, o) {
    n & 1 && u(0, "app-translate-desktop")
}
var Em = (() => {
    class n extends $ {
        constructor() {
            super(), this.store = s(D), this.transloco = s(pt), this.translation = s(ut), this.mediaMatcher = s(ft), this.meta = s(wn), this.title = s(Sn), this.spokenToSigned$ = this.store.select(e => e.translate.spokenToSigned), this.isMobile = this.mediaMatcher.matchMedia("screen and (max-width: 599px)"), this.store.dispatch([new Se("receiveVideo", !0), new Se("detectSign", !1), new Se("drawSignWriting", !1), new Se("drawPose", !0), new Se("poseViewer", "pose")])
        }
        ngOnInit() {
            this.transloco.events$.pipe(T(() => {
                this.title.setTitle(this.transloco.translate("translate.title")), this.meta.updateTag({
                    name: "description",
                    content: this.transloco.translate("translate.description")
                }, "name=description")
            }), y(this.ngUnsubscribe)).subscribe(), this.spokenToSigned$.pipe(ce(e => !e), T(() => {
                this.store.dispatch(new Se("drawSignWriting", !0))
            }), y(this.ngUnsubscribe)).subscribe(), this.playVideos()
        }
        playVideos() {
            return M(this, null, function*() {
                "window" in globalThis && R(window, "click").pipe(T(() => M(this, null, function*() {
                    let e = Array.from(document.getElementsByTagName("video"));
                    for (let t of e)
                        if (t.autoplay && t.paused) try {
                            yield t.play()
                        } catch (i) {
                            console.error(i)
                        }
                })), y(this.ngUnsubscribe)).subscribe()
            })
        }
        static {
            this.\u0275fac = function(t) {
                return new(t || n)
            }
        }
        static {
            this.\u0275cmp = h({
                type: n,
                selectors: [
                    ["app-translate"]
                ],
                features: [P],
                decls: 2,
                vars: 1,
                template: function(t, i) {
                    t & 1 && g(0, Lr, 1, 0, "app-translate-mobile")(1, Or, 1, 0, "app-translate-desktop"), t & 2 && b(i.isMobile.matches ? 0 : 1)
                },
                dependencies: [ga, Dt],
                styles: [`app-translate-mobile[_ngcontent-%COMP%], app-translate-desktop[_ngcontent-%COMP%]{display:contents}
/*# sourceMappingURL=translate.component-OLLHBD5O.css.map */`]
            })
        }
    }
    return n
})();
export {
    Em as TranslateComponent
};
//# sourceMappingURL=translate.component-2DM77ETD.js.map